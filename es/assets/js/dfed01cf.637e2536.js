"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[6896],{7888:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2025/12/02/arquitectura-de-carton-piedra","metadata":{"permalink":"/es/blog/2025/12/02/arquitectura-de-carton-piedra","source":"@site/blog/2025-12-02-arquitectura-de-carton-piedra.md","title":"Arquitectura de cart\xf3n piedra: cuando el c\xf3digo parece limpio, pero no hay quien lo entienda","description":"Qu\xe9 es la arquitectura de cart\xf3n piedra, por qu\xe9 aparece y c\xf3mo mejorarla sin reescribir todo.","date":"2025-12-02T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/es/blog/tags/architecture","description":"Software architecture"},{"inline":true,"label":"refactor","permalink":"/es/blog/tags/refactor"},{"inline":false,"label":"Best Practices","permalink":"/es/blog/tags/best-practices","description":"Software development best practices"}],"readingTime":5.48,"hasTruncateMarker":false,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/es/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"title":"Arquitectura de cart\xf3n piedra: cuando el c\xf3digo parece limpio, pero no hay quien lo entienda","description":"Qu\xe9 es la arquitectura de cart\xf3n piedra, por qu\xe9 aparece y c\xf3mo mejorarla sin reescribir todo.","authors":["valdepeace"],"date":"2025-12-02","tags":["architecture","refactor","best-practices"]},"unlisted":false,"nextItem":{"title":"Cardboard Architecture: when code looks clean but nobody understands it","permalink":"/es/blog/2025/12/02/cardboard-architecture"}},"content":"## Arquitectura de cart\xf3n piedra: cuando el c\xf3digo parece limpio, pero no hay quien lo entienda\\n\\nHay proyectos que, al abrirlos, dan muy buena impresi\xf3n:\\n\\n* Carpetas bien puestas: `core`, `domain`, `infrastructure`, `services`, `helpers`\u2026\\n* Clases con nombres serios: `UserService`, `OrderManager`, `PaymentHandler`\u2026\\n* Documentaci\xf3n extensa, diagramas, README detallado\u2026\\n\\nY sin embargo, cuando intentas seguir **c\xf3mo funciona realmente el sistema**, te encuentras con algo muy distinto:\\nm\xe9todos que llaman a otros m\xe9todos que llaman a otros m\xe9todos, capas que solo delegan, l\xf3gica de negocio repartida por todo el repositorio\u2026 y t\xfa pensando:\\n\\n> \u201cEsto parece muy arquitect\xf3nico, pero entenderlo es un dolor.\u201d\\n\\nA eso es a lo que me gusta llamar **arquitectura de cart\xf3n piedra**: por fuera parece s\xf3lida, pero por dentro no sostiene bien el peso del negocio.\\n\\n---\\n\\n## \xbfQu\xe9 es la \u201carquitectura de cart\xf3n piedra\u201d?\\n\\nNo es un t\xe9rmino oficial, pero describe muy bien una situaci\xf3n bastante com\xfan:\\n\\n> **Arquitectura de cart\xf3n piedra**: cuando se construye una estructura de carpetas y capas que *simula* una arquitectura limpia, pero en la pr\xe1ctica no ayuda a entender el flujo ni a mantener el sistema.\\n\\nAlgunos s\xedntomas t\xedpicos:\\n\\n* Abres el proyecto y ves mil capas, pero **no sabes d\xf3nde vive el negocio**.\\n* Para seguir un caso de uso sencillo (por ejemplo, crear un pedido) tienes que abrir **8\u201310 ficheros**.\\n* La mayor\xeda de las clases son **pasamanos**:\\n\\n  * `Controller` \u2192 `Manager` \u2192 `Handler` \u2192 `Service` \u2192 `Processor` \u2192 `Repository`\u2026\\n    y cada uno solo delega al siguiente.\\n* La l\xf3gica de negocio est\xe1 **fragmentada**:\\n\\n  * un trozo en el controller,\\n  * otro en un helper,\\n  * otro en el repositorio,\\n  * otro en un \u201cutil\u201d gen\xe9rico.\\n\\nPuede haber documentaci\xf3n muy buena\u2026\\npero si la estructura del c\xf3digo no refleja bien el negocio, **la arquitectura no est\xe1 cumpliendo su funci\xf3n**.\\n\\n---\\n\\n## \xbfPor qu\xe9 pasa esto?\\n\\nNormalmente se mezclan varias cosas:\\n\\n1. **Dise\xf1ar por carpeta, no por dominio**\\n   Se copia una estructura \u201cde libro\u201d (o de otro proyecto) sin pensar si encaja con el negocio real.\\n\\n2. **Confundir \u201cm\xe1s capas\u201d con \u201cmejor arquitectura\u201d**\\n\\n   * Se a\xf1aden capas tipo `Manager`, `Handler`, `Processor`, etc.\\n   * Pero muchas veces esas capas no encapsulan nada nuevo, solo complican el recorrido.\\n\\n3. **Cargo cult de patrones**\\n   Se aplican etiquetas como \u201cClean Architecture\u201d, \u201cDDD\u201d, \u201cHexagonal\u201d\u2026\\n   pero solo en lo superficial: nombres de carpetas y clases, sin respetar los principios.\\n\\n4. **Miedo a equivocarse**\\n   Se crean capas \u201cpor si acaso las necesitamos luego\u201d,\\n   y al final se acumulan niveles de indirecci\xf3n innecesarios.\\n\\n---\\n\\n\\n## C\xf3mo se vive trabajar en un proyecto as\xed\\n\\nSi has ca\xeddo en uno de estos proyectos, probablemente te suena:\\n\\n* Para hacer un cambio peque\xf1o tienes que tocar c\xf3digo en **medio repositorio**.\\n* No est\xe1 claro d\xf3nde **deber\xeda** ir una nueva regla de negocio.\\n* Refactorizar da miedo porque no entiendes bien el flujo completo.\\n* La documentaci\xf3n se vuelve obligatoria porque el c\xf3digo, por s\xed solo, **no se explica**.\\n\\nUna arquitectura sana deber\xeda ser casi lo contrario:\\n\\n> Aunque no haya documentaci\xf3n perfecta,\\n> deber\xedas intuir d\xf3nde est\xe1n las cosas con solo ver la estructura b\xe1sica.\\n\\n---\\n\\n## \xbfC\xf3mo es una arquitectura que ayuda de verdad?\\n\\nUna buena arquitectura no va de tener muchas capas, sino de que:\\n\\n### 1. El flujo sea f\xe1cil de seguir\\n\\nEjemplo muy simple:\\n\\n```text\\nHTTP Request \u2192 Controller \u2192 Caso de uso \u2192 Repositorios/Adaptadores \u2192 Respuesta\\n```\\n\\nEs decir, puedes explicar qu\xe9 pasa con una frase y unos pocos ficheros.\\n\\n### 2. La l\xf3gica de negocio est\xe9 concentrada en sitios previsibles\\n\\nPor ejemplo:\\n\\n* `CreateOrderUseCase`\\n* `ReserveSeatService`\\n* `CalculatePriceDomainService`\\n\\nY no escondida en helpers gen\xe9ricos o en m\xe9todos random de un repositorio.\\n\\n### 3. Las capas existan por una raz\xf3n clara\\n\\nUn esquema t\xedpico (y suficiente en muchos casos) podr\xeda ser:\\n\\n* **Interface / API**: controllers, DTOs, validaciones de entrada.\\n* **Application**: casos de uso, orquestaci\xf3n de procesos.\\n* **Domain**: entidades, reglas de negocio puras.\\n* **Infrastructure**: repositorios, acceso a bases de datos, APIs externas, colas, etc.\\n\\nLa clave es que, si alguien te pregunta:\\n\\n> \u201c\xbfD\xf3nde est\xe1 la l\xf3gica de *reservar un curso*?\u201d\\n\\npuedas responder algo tipo:\\n\\n> \u201cMira en `application/ReserveCourse.ts` y en `domain/CourseReservation`.\u201d\\n\\nSin tener que hacer un *\u201cbuscar en todo el repo\u201d*.\\n\\n---\\n\\n## Checklist r\xe1pido: \xbfhuele a cart\xf3n piedra?\\n\\nAlgunas preguntas \xfatiles cuando revisas un proyecto:\\n\\n1. **\xbfCu\xe1ntos ficheros tengo que abrir para seguir un caso de uso sencillo?**\\n\\n   * Si son m\xe1s de 5\u20136, sospecha.\\n2. **\xbfCu\xe1ntas clases solo delegan sin a\xf1adir l\xf3gica nueva?**\\n\\n   * Si la mayor\xeda son \u201cpasamanos\u201d, sobran capas.\\n3. **\xbfS\xe9 claramente d\xf3nde vive el negocio?**\\n\\n   * \xbfHay un sitio claro para los casos de uso?\\n4. **\xbfLa estructura est\xe1 basada en \u201cfeatures\u201d o en \u201ccapas gen\xe9ricas\u201d?**\\n\\n   * `orders/`, `payments/`, `users/` suele ser m\xe1s \xfatil que\\n     `managers/`, `helpers/`, `processors/`.\\n5. **\xbfQu\xe9 pasa si el \u201cdesarrollador h\xe9roe\u201d no est\xe1?**\\n\\n   * \xbfEl equipo puede mantener el sistema sin \xe9l/ella?\\n\\nCuantas m\xe1s respuestas inc\xf3modas, m\xe1s probable que est\xe9s delante de una arquitectura de cart\xf3n piedra.\\n\\n---\\n\\n## C\xf3mo mejorar sin reescribirlo todo\\n\\nNo siempre puedes tirar el proyecto y empezar de cero (de hecho, casi nunca).\\nPero s\xed puedes **mejorar poco a poco**:\\n\\n### 1. Elegir un caso de uso clave y mapearlo\\n\\nPor ejemplo: \u201ccrear pedido\u201d.\\n\\n* Dibuja el flujo actual (aunque sea en un papel) desde el endpoint hasta la base de datos.\\n* Identifica capas que no aportan nada.\\n\\n### 2. Concentrar la l\xf3gica de negocio\\n\\n* Crea un `CreateOrderUseCase` o similar.\\n* Ve moviendo reglas dispersas (en controller, helpers, etc.) hacia ese caso de uso.\\n\\n### 3. Eliminar pasamanos innecesarios\\n\\n* Si un `Manager` solo llama a un `Service` sin a\xf1adir nada, fusi\xf3nalos.\\n* Menos capas, m\xe1s claridad.\\n\\n### 4. Nombrar por dominio, no por patr\xf3n\\n\\nMejor:\\n\\n* `AssignSeatToPassenger`\\n* `CalculateInvoiceTotals`\\n\\nque:\\n\\n* `SeatManager`\\n* `InvoiceProcessor`\\n\\n### 5. Documentar el flujo, no solo la arquitectura\\n\\nUn diagrama sencillo del tipo:\\n\\n```mermaid\\nflowchart LR\\n  A[HTTP Request] --\x3e B[OrderController]\\n  B --\x3e C[CreateOrderUseCase]\\n  C --\x3e D[OrderRepository]\\n```\\n\\nvale oro si realmente refleja lo que pasa.\\n\\n---\\n\\n## Cerrar el c\xedrculo\\n\\nAl final, la reflexi\xf3n es sencilla:\\n\\n* **Arquitectura no es cu\xe1ntas carpetas tienes**,\\n  sino cu\xe1nto te ayuda a pensar y cambiar el negocio.\\n* Documentar est\xe1 genial, pero la mejor documentaci\xf3n es un c\xf3digo y una estructura\\n  que \u201cse explican solos\u201d.\\n* Y un desarrollador realmente senior no es solo el que desarrolla r\xe1pido,\\n  sino el que deja un sistema que cualquier persona del equipo puede entender y seguir ampliando.\\n\\nSi al abrir un proyecto tienes la sensaci\xf3n de que todo est\xe1 muy \u201cbonito\u201d, pero **no puedes seguir el flujo sin sufrir**, probablemente no eres t\xfa: es cart\xf3n piedra.\\n\\nY la buena noticia es que, en cuanto empiezas a desarrollar ese olfato, tambi\xe9n empiezas a dise\xf1ar tus propios proyectos de forma distinta: menos postureo, m\xe1s claridad, m\xe1s negocio\u2026 y menos dolor para el siguiente que venga detr\xe1s (aunque ese siguiente seas t\xfa dentro de seis meses).\\n\\n---\\n\\nSi quieres, en otro post podemos hacer el \u201cmodo pr\xe1ctico\u201d: coger un caso de uso real tuyo y ense\xf1ar un *antes vs despu\xe9s* de refactor, con c\xf3digo."},{"id":"/2025/12/02/cardboard-architecture","metadata":{"permalink":"/es/blog/2025/12/02/cardboard-architecture","source":"@site/blog/2025-12-02-cardboard-architecture.md","title":"Cardboard Architecture: when code looks clean but nobody understands it","description":"What \'cardboard architecture\' is, why it appears, and how to improve it without rewriting everything.","date":"2025-12-02T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/es/blog/tags/architecture","description":"Software architecture"},{"inline":true,"label":"refactor","permalink":"/es/blog/tags/refactor"},{"inline":false,"label":"Best Practices","permalink":"/es/blog/tags/best-practices","description":"Software development best practices"}],"readingTime":4.97,"hasTruncateMarker":false,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/es/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"title":"Cardboard Architecture: when code looks clean but nobody understands it","description":"What \'cardboard architecture\' is, why it appears, and how to improve it without rewriting everything.","authors":["valdepeace"],"date":"2025-12-02","tags":["architecture","refactor","best-practices"]},"unlisted":false,"prevItem":{"title":"Arquitectura de cart\xf3n piedra: cuando el c\xf3digo parece limpio, pero no hay quien lo entienda","permalink":"/es/blog/2025/12/02/arquitectura-de-carton-piedra"},"nextItem":{"title":"Mastra vs Microsoft Agent Framework + Azure AI Foundry \u2014 Comparativa pr\xe1ctica","permalink":"/es/blog/mastra-vs-microsoft-agent-framework"}},"content":"## Cardboard Architecture: when code looks clean but nobody understands it\\n\\nSome projects give a great first impression when you open them:\\n\\n* Well-organized folders: `core`, `domain`, `infrastructure`, `services`, `helpers`\u2026\\n* Classes with serious names: `UserService`, `OrderManager`, `PaymentHandler`\u2026\\n* Extensive documentation, diagrams, detailed README\u2026\\n\\nAnd yet, when you try to follow **how the system actually works**, you find something very different:\\nmethods calling other methods calling other methods, layers that only delegate, business logic scattered across the repository\u2026 and you thinking:\\n\\n> \u201cThis looks architectural, but understanding it is painful.\u201d\\n\\nThat\u2019s what I like to call **cardboard architecture**: it looks solid on the outside but doesn\u2019t really hold the weight of the business inside.\\n\\n---\\n\\n## What is \u201ccardboard architecture\u201d?\\n\\nIt\u2019s not an official term, but it describes a very common situation well:\\n\\n> **Cardboard architecture**: when you build a folder-and-layer structure that *simulates* clean architecture, but in practice doesn\u2019t help you understand the flow or maintain the system.\\n\\nTypical symptoms:\\n\\n* You open the project and see a thousand layers, but **you don\u2019t know where the business logic lives**.\\n* To follow a simple use case (e.g., create an order) you need to open **8\u201310 files**.\\n* Most classes are **pass-throughs**:\\n\\n  * `Controller` \u2192 `Manager` \u2192 `Handler` \u2192 `Service` \u2192 `Processor` \u2192 `Repository`\u2026\\n    and each one just delegates to the next.\\n* Business logic is **fragmented**:\\n\\n  * a bit in the controller,\\n  * another in a helper,\\n  * another in the repository,\\n  * another in a generic `util`.\\n\\nThere may be excellent documentation\u2026\\nbut if the code structure doesn\u2019t reflect the business, **the architecture fails its purpose**.\\n\\n---\\n\\n## Why does this happen?\\n\\nUsually several things mix together:\\n\\n1. **Designing by folder, not by domain**\\n   Copying a \u201ctextbook\u201d structure (or another project) without thinking if it fits the real business.\\n\\n2. **Confusing \u201cmore layers\u201d with \u201cbetter architecture\u201d**\\n\\n   * Adding layers like `Manager`, `Handler`, `Processor`, etc.\\n   * But often those layers don\u2019t encapsulate anything new, they just complicate the path.\\n\\n3. **Cargo-culting patterns**\\n   Applying labels like \u201cClean Architecture\u201d, \u201cDDD\u201d, \u201cHexagonal\u201d\u2026\\n   but only superficially: folder and class names, not the principles.\\n\\n4. **Fear of being wrong**\\n   Creating layers \u201cin case we need them later\u201d,\\n   and ending up with accumulated unnecessary indirection levels.\\n\\n---\\n\\n\\n## What it feels like to work on such a project\\n\\nIf you\u2019ve landed in one of these projects, this will sound familiar:\\n\\n* To make a small change you have to touch code across **half the repo**.\\n* It\u2019s unclear where a new business rule **should** live.\\n* Refactoring is scary because you don\u2019t fully understand the whole flow.\\n* Documentation becomes mandatory because the code alone **doesn\u2019t explain itself**.\\n\\nA healthy architecture should be almost the opposite:\\n\\n> Even without perfect docs,\\n> you should be able to guess where things live just by looking at the basic structure.\\n\\n---\\n\\n## What does an actually helpful architecture look like?\\n\\nGood architecture isn\u2019t about having many layers, it\u2019s about:\\n\\n### 1. The flow being easy to follow\\n\\nVery simple example:\\n\\n```text\\nHTTP Request \u2192 Controller \u2192 Use Case \u2192 Repositories/Adapters \u2192 Response\\n```\\n\\nMeaning you can explain what happens in one sentence and a few files.\\n\\n### 2. Business logic concentrated in predictable places\\n\\nFor example:\\n\\n* `CreateOrderUseCase`\\n* `ReserveSeatService`\\n* `CalculatePriceDomainService`\\n\\nNot hidden in generic helpers or random repository methods.\\n\\n### 3. Layers existing for a clear reason\\n\\nA typical (and often sufficient) layout could be:\\n\\n* **Interface / API**: controllers, DTOs, input validation.\\n* **Application**: use cases, process orchestration.\\n* **Domain**: entities, pure business rules.\\n* **Infrastructure**: repositories, DB access, external APIs, queues, etc.\\n\\nThe key is that if someone asks:\\n\\n> \u201cWhere is the logic to *reserve a course*?\u201d\\n\\nyou can answer:\\n\\n> \u201cLook in `application/ReserveCourse.ts` and `domain/CourseReservation`.\u201d\\n\\nwithout doing a repo-wide search.\\n\\n---\\n\\n## Quick checklist: does it smell like cardboard architecture?\\n\\nSome useful questions when reviewing a project:\\n\\n1. **How many files do I need to open to follow a simple use case?**\\n\\n   * If more than 5\u20136, be suspicious.\\n2. **How many classes only delegate without adding logic?**\\n\\n   * If most are passthroughs, you have too many layers.\\n3. **Do I clearly know where the business lives?**\\n\\n   * Is there a clear place for use cases?\\n4. **Is the structure feature-based or generic layers-based?**\\n\\n   * `orders/`, `payments/`, `users/` is often more useful than\\n     `managers/`, `helpers/`, `processors/`.\\n5. **What happens if the \u201chero developer\u201d is not available?**\\n\\n   * Can the team maintain the system without them?\\n\\nThe more uncomfortable answers, the more likely you\u2019re facing cardboard architecture.\\n\\n---\\n\\n## How to improve without rewriting everything\\n\\nYou rarely can throw away the project and start over (in fact, almost never).\\nBut you can **improve incrementally**:\\n\\n### 1. Pick a key use case and map it\\n\\nExample: \u201ccreate order\u201d.\\n\\n* Draw the current flow (even on paper) from endpoint to DB.\\n* Identify layers that contribute nothing.\\n\\n### 2. Concentrate business logic\\n\\n* Create a `CreateOrderUseCase` or similar.\\n* Move scattered rules (in controllers, helpers, etc.) into that use case.\\n\\n### 3. Remove unnecessary pass-throughs\\n\\n* If a `Manager` only calls a `Service` without adding value, merge them.\\n* Fewer layers, more clarity.\\n\\n### 4. Name by domain, not by pattern\\n\\nBetter:\\n\\n* `AssignSeatToPassenger`\\n* `CalculateInvoiceTotals`\\n\\nthan:\\n\\n* `SeatManager`\\n* `InvoiceProcessor`\\n\\n### 5. Document the flow, not only the architecture\\n\\nA simple diagram like:\\n\\n```mermaid\\nflowchart LR\\n  A[HTTP Request] --\x3e B[OrderController]\\n  B --\x3e C[CreateOrderUseCase]\\n  C --\x3e D[OrderRepository]\\n```\\n\\nis gold if it truly reflects what happens.\\n\\n---\\n\\n## Closing the loop\\n\\nThe takeaway is simple:\\n\\n* **Architecture is not how many folders you have**,\\n  it\u2019s how much it helps you think about and change the business.\\n* Documentation is great, but the best documentation is code and structure that \u201cexplain themselves\u201d.\\n* A truly senior developer is not just fast,\\n  but the one who leaves a system any teammate can understand and extend.\\n\\nIf a project looks pretty but you **can\u2019t** follow the flow without suffering, it\u2019s probably not you: it\u2019s cardboard.\\n\\nAnd the good news: once you develop that sense, you start designing your own projects differently: less posture, more clarity, more business focus\u2026 and less pain for whoever comes next (even if that\u2019s you in six months).\\n\\n---\\n\\nIf you want, in another post we can do the \u201cpractical mode\u201d: take a real use case of yours and show a before vs after refactor, with code."},{"id":"mastra-vs-microsoft-agent-framework","metadata":{"permalink":"/es/blog/mastra-vs-microsoft-agent-framework","source":"@site/i18n/es/docusaurus-plugin-content-blog/2025-11-29-mastra-vs-microsoft-agent-framework.md","title":"Mastra vs Microsoft Agent Framework + Azure AI Foundry \u2014 Comparativa pr\xe1ctica","description":"Resumen: Comparativa entre Mastra (framework TypeScript) y Microsoft Agent Framework + Azure AI Foundry.","date":"2025-11-29T00:00:00.000Z","tags":[{"inline":false,"label":"Mastra","permalink":"/es/blog/tags/mastra","description":"Framework Mastra (TypeScript) para agentes"},{"inline":false,"label":"Microsoft Agent Framework","permalink":"/es/blog/tags/microsoft-agent-framework","description":"Microsoft Agent Framework y Azure AI Foundry"},{"inline":false,"label":"Comparativa","permalink":"/es/blog/tags/comparativa","description":"Art\xedculos comparativos"},{"inline":false,"label":"Agentes AI","permalink":"/es/blog/tags/agentes-ai","description":"Frameworks de agentes y agentes IA"}],"readingTime":2.52,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/es/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"mastra-vs-microsoft-agent-framework","title":"Mastra vs Microsoft Agent Framework + Azure AI Foundry \u2014 Comparativa pr\xe1ctica","authors":["valdepeace"],"tags":["mastra","microsoft-agent-framework","comparativa","agentes-ai"]},"unlisted":false,"prevItem":{"title":"Cardboard Architecture: when code looks clean but nobody understands it","permalink":"/es/blog/2025/12/02/cardboard-architecture"},"nextItem":{"title":"Ni todo es una PoC, ni hay que hacer un Netflix para un CRUD","permalink":"/es/blog/over-engineering-vs-poc"}},"content":"Resumen: Comparativa entre Mastra (framework TypeScript) y Microsoft Agent Framework + Azure AI Foundry.\\n\\n\x3c!--truncate--\x3e\\n\\n## 1. Introducci\xf3n\\n\\nDos formas de construir agentes de IA en producci\xf3n:\\n\\n- **Mastra**: framework de agentes en TypeScript que pone el runtime y la orquestaci\xf3n en tu backend.\\n- **Agent Framework + Azure AI Foundry**: librer\xeda de orquestaci\xf3n (.NET/Python) m\xe1s un servicio gestionado en Azure donde viven agentes, threads y runs.\\n\\n## 2. Modelo mental com\xfan: agents, threads y runs\\n\\nConceptos compartidos:\\n\\n- **Agent**: persona virtual con instrucciones, modelo, tools y memoria.\\n- **Thread / Session**: hilo de conversaci\xf3n que mantiene el contexto.\\n- **Messages**: intercambio entre `user` y `assistant`.\\n- **Run**: ejecuci\xf3n concreta del agente.\\n\\nLa diferencia principal es d\xf3nde vive la m\xe1quina de estados: en tu backend (Mastra) o en un servicio gestionado (Azure AI Agents).\\n\\n---\\n\\n## 3. \xbfQu\xe9 ofrece cada enfoque?\\n\\n### Mastra\\n\\n- Framework TS + runtime en tu app.\\n- Tools, workflows, RAG, trazas y evaluaciones (Mastra Cloud).\\n- Buena DX para equipos JS/TS.\\n\\n### Agent Framework + Azure AI Foundry\\n\\n- Agent Framework para orquestaci\xf3n (.NET/Python).\\n- Azure AI Foundry como servicio gestionado (agentes, threads, runs).\\n- Integraci\xf3n nativa con AI Search, Fabric, OneLake y servicios Azure.\\n\\n---\\n\\n## 4. Tabla comparativa (resumen)\\n\\n| Aspecto | Mastra | Agent Framework + Azure Foundry |\\n|---|---|---|\\n| Tipo | Framework TS + observabilidad | Librer\xeda (.NET/Python) + servicio gestionado |\\n| Lenguaje | TypeScript / Node | .NET / Python |\\n| Runtime | En tu backend | En Azure (servicio gestionado) |\\n| Integraci\xf3n Azure | V\xeda SDKs | Nativa |\\n| Lock-in | Bajo | Medio/alto |\\n\\n---\\n\\n## 5. Pros y contras\\n\\n### Pros y contras \u2014 Mastra\\n\\n#### Pros \u2014 Mastra\\n\\n- 100% TypeScript; alta velocidad de desarrollo en JS stacks.\\n- Control total del runtime y orquestaci\xf3n.\\n\\n#### Contras \u2014 Mastra\\n\\n- Debes gestionar infraestructura y gobernanza por tu cuenta.\\n\\n### Pros y contras \u2014 Agent Framework + Foundry\\n\\n#### Pros \u2014 Agent Framework + Foundry\\n\\n- Servicio gestionado para threads/runs y escalado.\\n- Integraci\xf3n y gobierno enterprise en Azure.\\n\\n#### Contras \u2014 Agent Framework + Foundry\\n\\n- Mayor acoplamiento a la plataforma Azure.\\n\\n---\\n\\n## 6. Enfoque h\xedbrido (recomendado en muchos casos)\\n\\n- Mant\xe9n un n\xfacleo de agentes/producto en Mastra para iteraci\xf3n r\xe1pida.\\n- Usa Foundry como herramienta especializada para datos y gobernanza, expuesta como APIs.\\n\\n## 7. Ejemplo r\xe1pido (esquema)\\n\\n```ts\\n// hybridAgent.ts (esquema)\\nimport { createAgent } from \\"mastra\\";\\n\\nexport const hybridAgent = createAgent({\\n  name: \\"hybrid-agent\\",\\n  instructions: \\"Decide cu\xe1ndo delegar a Azure\\",\\n  model: { provider: \\"openai\\", name: \\"gpt-4o-mini\\" },\\n  tools: {\\n    askAzure: {\\n      description: \\"Consulta al agente de Azure\\",\\n      execute: async ({ query }: { query: string }) => ({ answer: \\"(respuesta simulada)\\" }),\\n    },\\n  },\\n});\\n```\\n\\n---\\n\\n## 8. Conclusi\xf3n\\n\\n- Si tu equipo vive en TypeScript, Mastra facilita iterar r\xe1pido.\\n- Si necesitas gobernanza y servicios Azure, Agent Framework + Foundry encaja mejor.\\n- La combinaci\xf3n h\xedbrida suele ofrecer lo mejor de ambos mundos.\\n\\n---\\n\\n## Referencias\\n\\n- Documentaci\xf3n de Mastra \u2014 [https://mastra.ai/docs](https://mastra.ai/docs)\\n- Repositorio Mastra en GitHub \u2014 [https://github.com/mastra-ai/mastra](https://github.com/mastra-ai/mastra)\\n- Libro/gu\xeda de Mastra \u2014 [https://mastra.ai/book](https://mastra.ai/book)\\n- Plantillas Mastra \u2014 [https://mastra.ai/templates](https://mastra.ai/templates)\\n- Azure AI Foundry (Microsoft Learn) \u2014 [https://learn.microsoft.com/es-es/azure/ai-foundry/](https://learn.microsoft.com/es-es/azure/ai-foundry/)\\n- SDK Azure AI Agents (`@azure/ai-agents`) \u2014 [https://www.npmjs.com/package/@azure/ai-agents](https://www.npmjs.com/package/@azure/ai-agents)\\n- Azure Identity (`@azure/identity`) \u2014 [https://www.npmjs.com/package/@azure/identity](https://www.npmjs.com/package/@azure/identity)\\n- Documentaci\xf3n general de Azure \u2014 [https://learn.microsoft.com/azure](https://learn.microsoft.com/azure)"},{"id":"over-engineering-vs-poc","metadata":{"permalink":"/es/blog/over-engineering-vs-poc","source":"@site/i18n/es/docusaurus-plugin-content-blog/2025-11-16-over-engineering-vs-poc.md","title":"Ni todo es una PoC, ni hay que hacer un Netflix para un CRUD","description":"En los \xfaltimos a\xf1os he visto dos extremos igual de da\xf1inos en muchos equipos de desarrollo: el de la sobre-ingenier\xeda y el de la PoC eterna. Este post va de por qu\xe9 ambos extremos son una mala pr\xe1ctica de ingenier\xeda y de c\xf3mo encontrar un punto medio razonable.","date":"2025-11-16T00:00:00.000Z","tags":[{"inline":false,"label":"Arquitectura","permalink":"/es/blog/tags/arquitectura","description":"Arquitectura de software"},{"inline":false,"label":"Buenas Pr\xe1cticas","permalink":"/es/blog/tags/buenas-practicas","description":"Buenas pr\xe1cticas de desarrollo"},{"inline":false,"label":"Ingenier\xeda Software","permalink":"/es/blog/tags/ingenieria-software","description":"Principios y pr\xe1cticas de ingenier\xeda de software"},{"inline":false,"label":"Deuda T\xe9cnica","permalink":"/es/blog/tags/deuda-tecnica","description":"Gesti\xf3n de deuda t\xe9cnica"}],"readingTime":6.54,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/es/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"over-engineering-vs-poc","title":"Ni todo es una PoC, ni hay que hacer un Netflix para un CRUD","authors":["valdepeace"],"tags":["arquitectura","buenas-practicas","ingenieria-software","deuda-tecnica"]},"unlisted":false,"prevItem":{"title":"Mastra vs Microsoft Agent Framework + Azure AI Foundry \u2014 Comparativa pr\xe1ctica","permalink":"/es/blog/mastra-vs-microsoft-agent-framework"},"nextItem":{"title":"\xa1Bienvenido a mi blog!","permalink":"/es/blog/welcome"}},"content":"En los \xfaltimos a\xf1os he visto dos extremos igual de da\xf1inos en muchos equipos de desarrollo: el de la **sobre-ingenier\xeda** y el de la **PoC eterna**. Este post va de por qu\xe9 ambos extremos son una mala pr\xe1ctica de ingenier\xeda y de c\xf3mo encontrar un punto medio razonable.\\n\\n\x3c!--truncate--\x3e\\n\\n## Qu\xe9 llamo \\"sobre-ingenier\xeda\\"\\n\\nPor sobre-ingenier\xeda me refiero a soluciones que:\\n\\n* A\xf1aden **complejidad accidental** sin aportar valor claro.\\n* Rompen principios b\xe1sicos como **KISS** (\\"Keep It Simple, Stupid\\"), **YAGNI** (\\"You Aren\'t Gonna Need It\\") y **DRY** (\\"Don\'t Repeat Yourself\\").\\n\\nAlgunos olores t\xedpicos:\\n\\n* Microservicios para un producto que no tiene ni PM dedicado.\\n* Arquitectura hexagonal + DDD + CQRS + Event Sourcing\u2026 para una intranet de 50 usuarios.\\n* Framework interno propio que solo entiende la persona que lo cre\xf3.\\n\\nEl problema no es usar patrones avanzados; el problema es hacerlo **sin un caso de negocio** que lo respalde. La complejidad hay que \\"pagarla\\" todos los d\xedas: onboarding, debugging, observabilidad, despliegues, refactors\u2026\\n\\n> Si el coste cognitivo de entender el sistema es mayor que el problema que resuelve, probablemente est\xe1s sobre-ingenierizando.\\n\\n## Qu\xe9 llamo \\"cultura PoC\\" (y por qu\xe9 es igual de t\xf3xica)\\n\\nEn el otro extremo est\xe1 la cultura de:\\n\\n> \\"Haz una PoC r\xe1pida, la ponemos en producci\xf3n para probar y ya luego la refactorizamos\\".\\n\\nSpoiler: **\\"luego\\" nunca llega**.\\n\\nUna PoC (Proof of Concept) est\xe1 pensada para **validar una idea con el m\xednimo esfuerzo**, no para durar a\xf1os: no suele tener test, ni buenas pr\xe1cticas de seguridad, ni observabilidad decente. Pasar esa PoC tal cual a producci\xf3n es una f\xe1brica de deuda t\xe9cnica.\\n\\nY aqu\xed est\xe1 la trampa:\\n\\n* La PoC **funciona**, el negocio se acostumbra.\\n* Se conectan m\xe1s cosas alrededor.\\n* Ya \\"da miedo\\" tocarla porque \\"lo rompe todo\\".\\n* Refactorizar se vuelve cada vez m\xe1s caro.\\n\\nComo resumi\xf3 Jason Lengstorf: casi todas las empresas tienen c\xf3digo en producci\xf3n que naci\xf3 como PoC y nunca se reescribi\xf3.\\n\\n## Deuda t\xe9cnica: herramienta, no excusa\\n\\nAqu\xed entra el concepto de **deuda t\xe9cnica**: tomar un atajo ahora sabiendo que pagar\xe1s un coste extra de mantenimiento en el futuro.\\n\\nMartin Fowler propone un cuadrante muy \xfatil: **prudente vs temeraria** y **deliberada vs inadvertida**.\\n\\n* **Deliberada + prudente**:\\n  Sabes que est\xe1s metiendo deuda, la aceptas conscientemente y tienes un plan para pagarla. Ejemplo: hacer algo m\xe1s \\"hardcodeado\\" para llegar a un lanzamiento, con tarea creada para refactorizar despu\xe9s.\\n\\n* **Deliberada + temeraria**:\\n  \\"No tenemos tiempo para dise\xf1o, ya se ver\xe1\\". Sin plan de limpieza. Esto es gasolina para incendios futuros.\\n\\n* **Inadvertida + prudente**:\\n  Hiciste lo mejor que sab\xedas, pero m\xe1s tarde aprendes una forma mejor. Normal.\\n\\n* **Inadvertida + temeraria**:\\n  C\xf3digo chapucero por desconocimiento y sin intenci\xf3n de mejorar.\\n\\nLa moraleja: **la deuda t\xe9cnica buena existe** (es una inversi\xf3n estrat\xe9gica); la mala es la que metes sin saberlo o sabiendo que no la vas a pagar.\\n\\n## C\xf3mo se alimentan mutuamente la sobre-ingenier\xeda y la cultura PoC\\n\\nLo gracioso (o triste) es que estas dos patolog\xedas **se refuerzan entre s\xed**:\\n\\n1. Un equipo sufre sobre-ingenier\xeda:\\n   * Cambiar algo en el sistema es car\xedsimo.\\n   * Todo lleva semanas.\\n   * El negocio se frustra.\\n\\n2. El negocio responde con \\"modo PoC\\":\\n   * \\"Haced algo r\xe1pido al margen, aunque sea feo, pero que funcione ya\\".\\n   * Nace una PoC paralela, sin disciplina de ingenier\xeda.\\n\\n3. Esa PoC termina en producci\xf3n.\\n   * Ahora tienes un monstruo: arquitectura excesiva en un lado, spaghetti experimental en otro.\\n\\nY vuelta a empezar.\\n\\n## Marco pr\xe1ctico para devs/arquitectos: \xbfPoC r\xe1pida o ingenier\xeda \\"en serio\\"?\\n\\nComo arquitecto o referente t\xe9cnico, tu trabajo no es aplicar patrones de libro, sino **tomar decisiones conscientes de coste/beneficio**.\\n\\n### 1. Check r\xe1pido para evitar la sobre-ingenier\xeda\\n\\nAntes de a\xf1adir otra capa, otro microservicio o un patr\xf3n nuevo, preg\xfantate:\\n\\n1. **\xbfQu\xe9 problema concreto resuelve hoy esto?**\\n   Si la respuesta es \\"por si ma\xf1ana\u2026\\", suena a YAGNI.\\n\\n2. **\xbfTengo se\xf1ales reales de que lo futuro va a llegar?**\\n   M\xe9tricas, roadmap, clientes, no solo \\"intuici\xf3n arquitect\xf3nica\\".\\n\\n3. **\xbfPuedo empezar con algo m\xe1s simple y extraerlo luego?**\\n   Por ejemplo:\\n   * Empezar con un m\xf3dulo en un monolito \u2192 extraer a microservicio cuando haya necesidad clara.\\n   * Empezar con una \xfanica base de datos \u2192 separar m\xe1s tarde por bounded contexts cuando duela de verdad.\\n\\n4. **\xbfMi equipo est\xe1 preparado para la complejidad que introduzco?**\\n   Una arquitectura es tan buena como la gente que la tiene que mantener.\\n\\nSi no puedes justificar la complejidad en t\xe9rminos de **riesgo reducido o coste ahorrado**, probablemente est\xe1s dise\xf1ando para tu ego m\xe1s que para el producto.\\n\\n### 2. Check r\xe1pido para evitar la PoC eterna\\n\\nCuando alguien diga \\"es solo una prueba\\", piensa:\\n\\n1. **\xbfEste c\xf3digo puede estar en producci\xf3n dentro de 6\u201312 meses?**\\n   Si la respuesta honesta es \\"s\xed, es probable\\", entonces no es \\"solo una PoC\\":\\n   * exige m\xednimo de calidad,\\n   * al menos unos tests b\xe1sicos,\\n   * logging decente y algo de observabilidad.\\n\\n2. **\xbfQu\xe9 parte del sistema depende de esto?**\\n   * \xbfVa a mover dinero?\\n   * \xbfAfecta a datos cr\xedticos?\\n   * \xbfA la experiencia principal del usuario?\\n\\n3. **\xbfEst\xe1 registrada la deuda que estoy metiendo?**\\n   No vale con \\"ya lo refactorizamos\\":\\n   * escribe tickets concretos,\\n   * asigna prioridades,\\n   * comenta el contexto en el c\xf3digo cuando tomes atajos.\\n\\n4. **\xbfHay una \\"fecha de caducidad\\" para esta PoC?**\\n   Por ejemplo:\\n   > \\"Este servicio PoC vivir\xe1 m\xe1ximo 3 meses. Si a los 3 meses sigue aportando valor, se planifica su reescritura/industrializaci\xf3n\\".\\n\\nSin timebox, la PoC muta en sistema legacy.\\n\\n## Patr\xf3n de trabajo recomendado: PoC \u2192 prototipo \u2192 producto\\n\\nUna forma sana de trabajar (sobre todo en entornos cloud / SaaS) es pensar en tres niveles:\\n\\n1. **PoC**\\n   * Objetivo: validar una idea (t\xe9cnica o de negocio).\\n   * Criterios m\xednimos:\\n     * Puede romperse; es para entorno controlado.\\n     * Documentas conscientemente: *\\"no est\xe1 pensado para producci\xf3n\\"*.\\n\\n2. **Prototipo \\"production-like\\"**\\n   * Objetivo: acercarse a lo que ser\xeda la versi\xf3n real.\\n   * Aqu\xed ya aplicas:\\n     * arquitectura que tenga sentido,\\n     * l\xedmites claros,\\n     * seguridad b\xe1sica,\\n     * observabilidad m\xednima.\\n\\n3. **Producto / servicio estable**\\n   * Objetivo: operar en producci\xf3n durante a\xf1os.\\n   * Exige:\\n     * SLOs/SLAs claros,\\n     * pipelines serios,\\n     * m\xe9tricas de fiabilidad,\\n     * estrategia de evoluci\xf3n.\\n\\nEl salto PoC \u2192 producto **sin fase intermedia** es lo que tantas veces acaba en pesadilla de deuda t\xe9cnica.\\n\\n## Qu\xe9 puedes hacer t\xfa como dev/arquitecto (aunque no seas \\"CTO\\")\\n\\nAlgunas acciones muy concretas que puedes meter en tu pr\xe1ctica diaria:\\n\\n* **Poner lenguaje a los atajos**\\n  Cuando alguien pida \\"hazlo r\xe1pido\\":\\n  * \\"Vale, pero eso implica deuda t\xe9cnica de tipo X. La aceptamos si luego dedicamos Y horas a limpiarla\\".\\n\\n* **Visibilizar la complejidad**\\n  * Diagrams sencillos (C4 nivel 1\u20132) para mostrar cu\xe1ndo la arquitectura se est\xe1 volviendo absurda para el tama\xf1o del producto.\\n\\n* **Medir el dolor**\\n  * \\"Cada cambio en este m\xf3dulo nos lleva dos semanas y rompe tres cosas\\".\\n  * Eso abre puertas para proponer refactors, simplificaci\xf3n o re-arquitectura.\\n\\n* **Negociar condiciones para una PoC**\\n  * Timebox claro.\\n  * Qu\xe9 se puede sacrificar (performance, limpieza interna) y qu\xe9 NO (seguridad b\xe1sica, privacidad, integridad de datos).\\n\\n## Conclusi\xf3n: ingenier\xeda \u2260 dogma, es gesti\xf3n de trade-offs\\n\\nNi todo proyecto merece una arquitectura de libro, ni todo vale con \\"total, es una prueba\\". Ambos extremos son, en el fondo, **falta de ingenier\xeda**:\\n\\n* La sobre-ingenier\xeda ignora el coste real de la complejidad.\\n* La cultura de PoC eterna ignora el coste real de la deuda t\xe9cnica.\\n\\nLa ingenier\xeda de software de verdad va de esto:\\n\\n> **Tomar decisiones expl\xedcitas sobre d\xf3nde aceptas complejidad y d\xf3nde aceptas deuda, con un plan para gestionar ambas en el tiempo.**\\n\\nSi algo te llevas de este post, que sea esta idea:\\n\\n* Cuando vayas a dise\xf1ar: preg\xfantate *\\"\xbfpuedo hacerlo m\xe1s simple sin perder lo esencial?\\"*.\\n* Cuando vayas a \\"hacer algo r\xe1pido\\": preg\xfantate *\\"\xbfestoy dispuesto a pagar el precio de dejarlo as\xed?\\"*.\\n\\nEl equilibrio no lo vas a encontrar en ning\xfan libro: lo vas a construir t\xfa, proyecto a proyecto, decisi\xf3n a decisi\xf3n.\\n\\n---\\n\\n## Referencias\\n\\n* [KISS vs. DRY vs. YAGNI: Understanding Key Software Development Principles](https://rrmartins.medium.com/kiss-vs-dry-vs-yagni-understanding-key-software-development-principles-e307b7419636)\\n* [Technical Debt Quadrant - Martin Fowler](https://martinfowler.com/bliki/TechnicalDebtQuadrant.html)\\n* [When Proof of Concepts Become Production Code](https://blog.scaledcode.com/blog/poc-to-production/)\\n* [YAGNI - Martin Fowler](https://martinfowler.com/bliki/Yagni.html)"},{"id":"welcome","metadata":{"permalink":"/es/blog/welcome","source":"@site/i18n/es/docusaurus-plugin-content-blog/2025-11-15-welcome.md","title":"\xa1Bienvenido a mi blog!","description":"\xa1Hola y bienvenido a mi blog personal! \ud83d\udc4b","date":"2025-11-15T00:00:00.000Z","tags":[{"inline":false,"label":"Personal","permalink":"/es/blog/tags/personal","description":"Personal posts"}],"readingTime":1.01,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/es/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"welcome","title":"\xa1Bienvenido a mi blog!","authors":["valdepeace"],"tags":["personal"]},"unlisted":false,"prevItem":{"title":"Ni todo es una PoC, ni hay que hacer un Netflix para un CRUD","permalink":"/es/blog/over-engineering-vs-poc"}},"content":"\xa1Hola y bienvenido a mi blog personal! \ud83d\udc4b\\n\\nEste es el primer post de muchos que vienen. Aqu\xed compartir\xe9 mis experiencias, aprendizajes y reflexiones sobre tecnolog\xeda, desarrollo de software y todo lo que me apasiona.\\n\\n\x3c!--truncate--\x3e\\n\\n## \xbfQu\xe9 encontrar\xe1s aqu\xed?\\n\\nEn este espacio publicar\xe9 contenido sobre:\\n\\n- **\ud83d\udcbb Desarrollo web:** Tutoriales, tips y mejores pr\xe1cticas\\n- **\ud83d\ude80 Tecnolog\xedas modernas:** React, TypeScript, Node.js, y m\xe1s\\n- **\ud83d\udcda Aprendizajes:** Experiencias y lecciones aprendidas\\n- **\ud83d\udd27 Herramientas:** Reviews y gu\xedas de herramientas \xfatiles\\n- **\ud83d\udca1 Ideas:** Reflexiones sobre la industria tech\\n\\n## Mi visi\xf3n\\n\\nCreo firmemente en compartir conocimiento. La comunidad de desarrolladores ha sido incre\xedblemente generosa conmigo, y esta es mi forma de devolver un poco de lo que he recibido.\\n\\nNo esperes posts perfectos, sino contenido honesto, pr\xe1ctico y \xfatil basado en experiencias reales.\\n\\n## \xbfQu\xe9 viene?\\n\\nEn los pr\xf3ximos posts hablar\xe9 sobre:\\n\\n- C\xf3mo configur\xe9 este sitio con Docusaurus\\n- Mejores pr\xe1cticas en React y TypeScript\\n- Herramientas que uso diariamente\\n- Proyectos en los que estoy trabajando\\n\\n## Mantente conectado\\n\\nSi te interesa el contenido, puedes:\\n\\n- Suscribirte al [RSS feed](/blog/rss.xml)\\n- Seguirme en [Twitter](https://twitter.com/valdepeace)\\n- Conectar en [LinkedIn](https://www.linkedin.com/in/valdepeace)\\n- Ver mi trabajo en [GitHub](https://github.com/valdepeace)\\n\\n\xa1Gracias por estar aqu\xed! \ud83d\ude80\\n\\n---\\n\\n*\xbfTienes alg\xfan tema que te gustar\xeda que cubriera? \xa1D\xe9jame un comentario o contact\xe1ctame!*"}]}}')}}]);