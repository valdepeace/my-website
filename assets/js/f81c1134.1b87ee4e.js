"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/authors/all-sebastien-lorber-articles","metadata":{"permalink":"/blog/authors/all-sebastien-lorber-articles","source":"@site/blog/authors/all-sebastien-lorber-articles.md","title":"Author","description":"This is a placeholder author page for all-sebastien-lorber-articles. Update with links or a proper bio as needed.","date":"2025-11-30T12:59:03.000Z","tags":[],"readingTime":0.11,"hasTruncateMarker":true,"authors":[],"frontMatter":{"name":"Sebastien Lorber","title":"Author","bio":"Placeholder page aggregating Sebastien Lorber\'s articles."},"unlisted":false,"nextItem":{"title":"Author","permalink":"/blog/authors/yangshun"}},"content":"This is a placeholder author page for `all-sebastien-lorber-articles`. Update with links or a proper bio as needed.\\n\\n\x3c!-- truncate --\x3e"},{"id":"/authors/yangshun","metadata":{"permalink":"/blog/authors/yangshun","source":"@site/blog/authors/yangshun.md","title":"Author","description":"This is a placeholder author page for yangshun. You can update this file with a fuller bio, avatar, and links.","date":"2025-11-30T12:59:03.000Z","tags":[],"readingTime":0.11,"hasTruncateMarker":true,"authors":[],"frontMatter":{"name":"Yangshun","title":"Author","bio":"Contributor and writer \u2014 placeholder author page."},"unlisted":false,"prevItem":{"title":"Author","permalink":"/blog/authors/all-sebastien-lorber-articles"},"nextItem":{"title":"Mastra vs Agent Framework + Azure AI Foundry","permalink":"/blog/mastra-vs-microsoft-agent-framework"}},"content":"This is a placeholder author page for `yangshun`. You can update this file with a fuller bio, avatar, and links.\\n\\n\x3c!-- truncate --\x3e"},{"id":"mastra-vs-microsoft-agent-framework","metadata":{"permalink":"/blog/mastra-vs-microsoft-agent-framework","source":"@site/blog/2025-11-29-mastra-vs-microsoft-agent-framework.md","title":"Mastra vs Agent Framework + Azure AI Foundry","description":"Two ways to build production AI agents","date":"2025-11-29T00:00:00.000Z","tags":[{"inline":false,"label":"Mastra","permalink":"/blog/tags/mastra","description":"Mastra TypeScript agent framework"},{"inline":false,"label":"Microsoft Agent Framework","permalink":"/blog/tags/microsoft-agent-framework","description":"Microsoft Agent Framework and Azure AI Foundry"},{"inline":false,"label":"Comparison","permalink":"/blog/tags/comparison","description":"Comparative articles"},{"inline":false,"label":"AI Agents","permalink":"/blog/tags/ai-agents","description":"Agent frameworks and AI agents"}],"readingTime":6.07,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"mastra-vs-microsoft-agent-framework","title":"Mastra vs Agent Framework + Azure AI Foundry","authors":["valdepeace"],"tags":["mastra","microsoft-agent-framework","comparison","ai-agents"]},"unlisted":false,"prevItem":{"title":"Author","permalink":"/blog/authors/yangshun"},"nextItem":{"title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","permalink":"/blog/over-engineering-vs-poc"}},"content":"## Two ways to build production AI agents\\n\\nIn recent months many frameworks for building AI agents have emerged. Two approaches I find particularly interesting are:\\n\\n- **Mastra**, an all-TypeScript agent framework that feels natural if your stack is Node-based.\\n- **Microsoft Agent Framework + Azure AI Foundry (Azure AI Agents)**, Microsoft\'s offering that pairs an orchestration library with a managed agent service on Azure.\\n\\nAt first glance they look like different worlds, but they share a similar mental model: agents that keep conversations via threads/sessions, messages, and runs.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n## 1. Shared mental model: agents, threads and runs\\n\\nBoth Mastra and Microsoft\'s stack can be understood with the same pattern:\\n\\n- **Agent**: A virtual \u201cperson\u201d with instructions, a model, tools and memory.\\n- **Thread / Session**: A conversation thread that preserves context.\\n- **Messages**: Exchanges between `user` and `assistant`.\\n- **Run**: A specific execution of an agent against a conversation.\\n\\nThe difference is less about concepts and more about where that state machine lives:\\n\\n- In **Mastra**, the state machine runs in your backend (Node/TS).\\n- In **Azure AI Agents**, the state machine lives in a **managed Azure service**.\\n\\n---\\n\\n## 2. What is Mastra?\\n\\nIn short:\\n\\n- It\'s an **agent framework in TypeScript**: agents, tools, workflows (flows/graphs), RAG, tracing and evals (Mastra Cloud).\\n- The **runtime** runs in your Node app (Express, Next.js, Lambdas, Functions, etc.).\\n- It integrates well with the JS/TS ecosystem: static typing, nice DX, a CLI and a dev server.\\n\\nThink of Mastra as an **all-in-one TypeScript-first agent platform**: runtime + agents + tools + workflows + tracing, all expressed in code.\\n\\n---\\n\\n## 3. What is Agent Framework + Azure AI Foundry?\\n\\nIn this stack the pieces are split into two complementary parts:\\n\\n### Microsoft Agent Framework\\n\\n- A library to **orchestrate agents and workflows** in .NET or Python.\\n- It lets you define graphs, steps, states, multi-agent scenarios, etc.\\n- You provide the runtime: App Service, Functions, Container Apps, AKS, and so on.\\n\\n### Azure AI Foundry / Azure AI Agents\\n\\n- A managed service that hosts agents (model + instructions + tools + memory), threads (conversations) and runs (executions).\\n- Consumed via SDKs (`@azure/ai-agents`, `azure-ai-agents`) or REST.\\n- Deeply integrated with the Foundry ecosystem: model deployments, AI Search, Fabric, Storage, etc.\\n\\nTogether they cover similar functionality to Mastra, but as **two complementary pieces** rather than a single all-in-one package.\\n\\n---\\n\\n## 4. High-level comparison\\n\\n| Aspect | Mastra | Agent Framework + Azure Foundry |\\n|---|---|---|\\n| Product type | TypeScript framework + observability (Mastra Cloud) | Orchestration library (.NET/Python) + managed service |\\n| Primary language | TypeScript / Node | .NET / Python (SDKs available) |\\n| Where runtime lives | In your backend (Node, Lambdas, Functions, etc.) | In your code + managed Azure agent service |\\n| Conversation unit | Session / conversationId | Thread |\\n| Executions | Runs / traces in your app + Mastra Cloud | Runs managed by the agent service |\\n| Primary models | Any provider supported by Mastra | Models from Azure catalog |\\n| Tools | JS/TS functions, HTTP, DB, MCP\u2026 | Native tools + OpenAPI/HTTP + function tools |\\n| Lock-in | Low (mostly depends on chosen LLM) | Medium/high (tied to Azure Foundry) |\\n| Azure integration | Via SDKs / standard APIs | Native (AI Search, Fabric, Storage, Monitor) |\\n| JS/TS learning curve | Very low | Medium (if also orchestrating with .NET/Python) |\\n\\n---\\n\\n## 5. DX: what it is and why it matters\\n\\nDX = Developer Experience. This includes how easy it is to get started, API clarity, type/autocomplete support, CLI and documentation.\\n\\n- For Node/TypeScript teams, Mastra\'s DX tends to feel natural.\\n- Microsoft\'s stack offers strong DX for .NET/Python and adds value if you\'re already deep in Azure, but it also introduces more mental models: Foundry projects, managed agents, Agent Framework, etc.\\n\\n---\\n\\n## 6. Pros and cons\\n\\n### Mastra\\n\\n#### Pros \u2014 Mastra\\n\\n- TypeScript-first: fits perfectly in modern Node stacks.\\n- Runtime under your control (`execute`, workflows in TS).\\n- Multi-provider model support.\\n- Natural integration with HTTP, DBs, MCP, etc.\\n- Good DX: CLI, dev server, tracing and evals in Mastra Cloud.\\n\\n#### Cons \u2014 Mastra\\n\\n- You must operate the infrastructure (Kubernetes, Functions, etc.).\\n- You handle enterprise governance/compliance yourself.\\n- No built-in, native Azure integrations by default.\\n\\n---\\n\\n### Agent Framework + Azure Foundry\\n\\n#### Pros \u2014 Agent Framework + Foundry\\n\\n- Managed agent service for threads/runs/state and scaling.\\n- Native integration with AI Search, Fabric, OneLake, Storage.\\n- Enterprise security and governance (Entra ID, Monitor, Defender).\\n- Native tools and OpenAPI/HTTP support.\\n\\n#### Cons \u2014 Agent Framework + Foundry\\n\\n- Platform lock-in: Foundry and its resources.\\n- Agent Framework is .NET/Python (no TS runtime like Mastra).\\n- The runs/threads model may be less flexible than running everything in TS.\\n\\n---\\n\\n## 7. Architecture diagrams\\n\\n### 7.1. Mastra-centric approach\\n\\n```mermaid\\nflowchart LR\\n  UI[Web/App] --\x3e|HTTP| MAS[Mastra Agents & Workflows]\\n  MAS --\x3e GATEWAY[LLM Gateway]\\n  GATEWAY --\x3e P1[Provider 1]\\n  GATEWAY --\x3e P2[Provider 2]\\n```\\n\\n### 7.2. Azure-centric approach\\n\\n```mermaid\\nflowchart LR\\n  UI --\x3e|HTTP| WF[Orchestrator (.NET/Python)]\\n  WF --\x3e|SDK/REST| AGENT[Azure Agent Service]\\n  AGENT --\x3e TOOLS[AI Search / Fabric / Storage]\\n```\\n\\n### 7.3. Hybrid approach\\n\\n```mermaid\\nflowchart LR\\n  UI --\x3e MAS[Mastra]\\n  MAS --\x3e GATEWAY\\n  MAS --\x3e AZ_TOOL[Tool: Azure Agent Service]\\n  AZ_TOOL --\x3e AZ_AGENT\\n```\\n\\n---\\n\\n## 8. Quick example: a TS agent delegating to Azure\\n\\nHybrid pattern: keep a primary agent in Mastra and give it a tool that calls a managed Azure agent.\\n\\n```ts\\n// azureAgentTool.ts\\nimport { AgentsClient } from \\"@azure/ai-agents\\";\\nimport { DefaultAzureCredential } from \\"@azure/identity\\";\\n\\nconst projectEndpoint = process.env.PROJECT_ENDPOINT!;\\nconst azureAgentId = process.env.AZURE_AGENT_ID!;\\n\\nconst agentsClient = new AgentsClient(\\n  projectEndpoint,\\n  new DefaultAzureCredential(),\\n);\\n\\nexport async function callAzureAgent(input: string): Promise<string> {\\n  const thread = await agentsClient.threads.create();\\n  await agentsClient.messages.create(thread.id, \\"user\\", input);\\n  const run = await agentsClient.runs.createAndPoll(thread.id, { agentId: azureAgentId });\\n  if (run.status !== \\"succeeded\\") throw new Error(`Azure agent run failed: ${run.status}`);\\n  let lastAnswer = \\"\\";\\n  for await (const msg of agentsClient.messages.list(thread.id)) {\\n    if (msg.role === \\"assistant\\") {\\n      const first = msg.content?.[0];\\n      if (first && (first as any).text) lastAnswer = (first as any).text;\\n    }\\n  }\\n  return lastAnswer || \\"The Azure agent did not return a text response.\\";\\n}\\n```\\n\\n```ts\\n// hybridAgent.ts (sketch)\\nimport { createAgent } from \\"mastra\\";\\nimport { callAzureAgent } from \\"./azureAgentTool\\";\\n\\nexport const hybridAgent = createAgent({\\n  name: \\"hybrid-agent\\",\\n  instructions: \\"You are an assistant that decides when to delegate queries to Azure.\\",\\n  model: { provider: \\"openai\\", name: \\"gpt-4o-mini\\" },\\n  tools: {\\n    askAzure: {\\n      description: \\"Use this tool to query the Azure agent\\",\\n      execute: async ({ query }: { query: string }) => ({ answer: await callAzureAgent(query) }),\\n    },\\n  },\\n});\\n```\\n\\n---\\n\\n## 9. Key idea: orchestration matters most\\n\\nBeyond choosing Mastra or Agent Framework + Foundry, the important part is **how you orchestrate your agents around business logic** and **how you manage conversational state**.\\n\\nMastra is an all-in-one TypeScript solution; in the Microsoft ecosystem you get Agent Framework (the orchestrator) + Foundry (the managed runtime). Often a hybrid combination delivers the best of both.\\n\\n---\\n\\n## 10. Conclusion\\n\\n- If your team lives in TypeScript, start with Mastra to iterate quickly.\\n- If your organization requires Azure-level governance and deep integration, use Agent Framework + Foundry.\\n- Often the most valuable approach is a combination: Mastra for product-layer agility and Foundry for specialist data/governance capabilities.\\n\\nIf you\'d like, I can create a short LinkedIn-ready version with the comparison table and the hybrid diagram.\\n\\n---\\n\\n## References\\n\\n- Mastra documentation \u2014 [https://mastra.ai/docs](https://mastra.ai/docs)\\n- Mastra GitHub \u2014 [https://github.com/mastra-ai/mastra](https://github.com/mastra-ai/mastra)\\n- Mastra Book (Principles of Building AI Agents) \u2014 [https://mastra.ai/book](https://mastra.ai/book)\\n- Mastra Templates \u2014 [https://mastra.ai/templates](https://mastra.ai/templates)\\n- Azure AI Foundry (Microsoft Learn) \u2014 [https://learn.microsoft.com/en-us/azure/ai-foundry/](https://learn.microsoft.com/en-us/azure/ai-foundry/)\\n- Azure AI Agents SDK (`@azure/ai-agents`) \u2014 [https://www.npmjs.com/package/@azure/ai-agents](https://www.npmjs.com/package/@azure/ai-agents)\\n- Azure Identity (`@azure/identity`) \u2014 [https://www.npmjs.com/package/@azure/identity](https://www.npmjs.com/package/@azure/identity)\\n- Azure AI & general docs \u2014 [https://learn.microsoft.com/azure](https://learn.microsoft.com/azure)"},{"id":"over-engineering-vs-poc","metadata":{"permalink":"/blog/over-engineering-vs-poc","source":"@site/blog/2025-11-16-over-engineering-vs-poc.md","title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","description":"In recent years, I\'ve seen two equally damaging extremes in many development teams: over-engineering and the eternal PoC culture. This post is about why both extremes are bad engineering practices and how to find a reasonable middle ground.","date":"2025-11-16T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture","description":"Software architecture"},{"inline":false,"label":"Best Practices","permalink":"/blog/tags/best-practices","description":"Software development best practices"},{"inline":false,"label":"Software Engineering","permalink":"/blog/tags/software-engineering","description":"Software engineering principles and practices"},{"inline":false,"label":"Technical Debt","permalink":"/blog/tags/technical-debt","description":"Technical debt management"}],"readingTime":6.54,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"over-engineering-vs-poc","title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","authors":["valdepeace"],"tags":["architecture","best-practices","software-engineering","technical-debt"]},"unlisted":false,"prevItem":{"title":"Mastra vs Agent Framework + Azure AI Foundry","permalink":"/blog/mastra-vs-microsoft-agent-framework"},"nextItem":{"title":"Welcome to my blog!","permalink":"/blog/welcome"}},"content":"In recent years, I\'ve seen two equally damaging extremes in many development teams: **over-engineering** and the **eternal PoC culture**. This post is about why both extremes are bad engineering practices and how to find a reasonable middle ground.\\n\\n\x3c!--truncate--\x3e\\n\\n## What I Call \\"Over-Engineering\\"\\n\\nBy over-engineering, I mean solutions that:\\n\\n* Add **accidental complexity** without providing clear value.\\n* Break basic principles like **KISS** (\\"Keep It Simple, Stupid\\"), **YAGNI** (\\"You Aren\'t Gonna Need It\\"), and **DRY** (\\"Don\'t Repeat Yourself\\").\\n\\nSome typical smells:\\n\\n* Microservices for a product that doesn\'t even have a dedicated PM.\\n* Hexagonal architecture + DDD + CQRS + Event Sourcing\u2026 for an intranet with 50 users.\\n* Internal framework that only the person who created it understands.\\n\\nThe problem isn\'t using advanced patterns; the problem is doing it **without a business case** to support it. Complexity has to be \\"paid for\\" every day: onboarding, debugging, observability, deployments, refactors\u2026\\n\\n> If the cognitive cost of understanding the system is greater than the problem it solves, you\'re probably over-engineering.\\n\\n## What I Call \\"PoC Culture\\" (and Why It\'s Equally Toxic)\\n\\nOn the other extreme is the culture of:\\n\\n> \\"Do a quick PoC, we\'ll put it in production to test it, and we\'ll refactor it later\\".\\n\\nSpoiler: **\\"later\\" never comes**.\\n\\nA PoC (Proof of Concept) is designed to **validate an idea with minimal effort**, not to last for years: it usually doesn\'t have tests, security best practices, or decent observability. Taking that PoC as-is to production is a technical debt factory.\\n\\nAnd here\'s the trap:\\n\\n* The PoC **works**, the business gets used to it.\\n* More things get connected around it.\\n* It becomes \\"scary\\" to touch because \\"it breaks everything\\".\\n* Refactoring becomes increasingly expensive.\\n\\nAs Jason Lengstorf summarized: almost every company has code in production that was born as a PoC and was never rewritten.\\n\\n## Technical Debt: Tool, Not Excuse\\n\\nThis is where the concept of **technical debt** comes in: taking a shortcut now knowing that you\'ll pay an extra maintenance cost in the future.\\n\\nMartin Fowler proposes a very useful quadrant: **prudent vs reckless** and **deliberate vs inadvertent**.\\n\\n* **Deliberate + prudent**:\\n  You know you\'re introducing debt, you accept it consciously, and you have a plan to pay it off. Example: doing something more \\"hardcoded\\" to reach a launch, with a task created to refactor later.\\n\\n* **Deliberate + reckless**:\\n  \\"We don\'t have time for design, we\'ll see\\". No cleanup plan. This is gasoline for future fires.\\n\\n* **Inadvertent + prudent**:\\n  You did the best you knew how, but later you learn a better way. Normal.\\n\\n* **Inadvertent + reckless**:\\n  Sloppy code due to lack of knowledge and no intention to improve.\\n\\nThe moral: **good technical debt exists** (it\'s a strategic investment); the bad kind is what you introduce unknowingly or knowing you won\'t pay it off.\\n\\n## How Over-Engineering and PoC Culture Feed Each Other\\n\\nThe funny (or sad) thing is that these two pathologies **reinforce each other**:\\n\\n1. A team suffers from over-engineering:\\n   * Changing anything in the system is extremely expensive.\\n   * Everything takes weeks.\\n   * The business gets frustrated.\\n\\n2. The business responds with \\"PoC mode\\":\\n   * \\"Do something quick on the side, even if it\'s ugly, but make it work now\\".\\n   * A parallel PoC is born, without engineering discipline.\\n\\n3. That PoC ends up in production.\\n   * Now you have a monster: excessive architecture on one side, experimental spaghetti on the other.\\n\\nAnd around we go again.\\n\\n## Practical Framework for Devs/Architects: Quick PoC or \\"Real\\" Engineering?\\n\\nAs an architect or technical lead, your job isn\'t to apply textbook patterns, but to **make conscious cost/benefit decisions**.\\n\\n### 1. Quick Check to Avoid Over-Engineering\\n\\nBefore adding another layer, another microservice, or a new pattern, ask yourself:\\n\\n1. **What specific problem does this solve today?**\\n   If the answer is \\"in case tomorrow\u2026\\", it sounds like YAGNI.\\n\\n2. **Do I have real signals that the future is coming?**\\n   Metrics, roadmap, customers, not just \\"architectural intuition\\".\\n\\n3. **Can I start with something simpler and extract it later?**\\n   For example:\\n   * Start with a module in a monolith \u2192 extract to microservice when there\'s clear need.\\n   * Start with a single database \u2192 separate later by bounded contexts when it really hurts.\\n\\n4. **Is my team prepared for the complexity I\'m introducing?**\\n   An architecture is only as good as the people who have to maintain it.\\n\\nIf you can\'t justify the complexity in terms of **reduced risk or saved cost**, you\'re probably designing for your ego rather than the product.\\n\\n### 2. Quick Check to Avoid the Eternal PoC\\n\\nWhen someone says \\"it\'s just a test\\", think:\\n\\n1. **Could this code be in production in 6\u201312 months?**\\n   If the honest answer is \\"yes, likely\\", then it\'s not \\"just a PoC\\":\\n   * require minimum quality,\\n   * at least some basic tests,\\n   * decent logging and some observability.\\n\\n2. **What part of the system depends on this?**\\n   * Will it move money?\\n   * Does it affect critical data?\\n   * The main user experience?\\n\\n3. **Is the debt I\'m introducing recorded?**\\n   \\"We\'ll refactor it later\\" doesn\'t cut it:\\n   * write concrete tickets,\\n   * assign priorities,\\n   * comment the context in the code when taking shortcuts.\\n\\n4. **Is there an \\"expiration date\\" for this PoC?**\\n   For example:\\n   > \\"This PoC service will live for a maximum of 3 months. If after 3 months it\'s still providing value, we plan its rewrite/industrialization\\".\\n\\nWithout a timebox, the PoC mutates into legacy system.\\n\\n## Recommended Work Pattern: PoC \u2192 Prototype \u2192 Product\\n\\nA healthy way to work (especially in cloud/SaaS environments) is to think in three levels:\\n\\n1. **PoC**\\n   * Objective: validate an idea (technical or business).\\n   * Minimum criteria:\\n     * It can break; it\'s for controlled environment.\\n     * You document consciously: *\\"not intended for production\\"*.\\n\\n2. **\\"Production-like\\" Prototype**\\n   * Objective: approach what the real version would be.\\n   * Here you already apply:\\n     * architecture that makes sense,\\n     * clear boundaries,\\n     * basic security,\\n     * minimum observability.\\n\\n3. **Stable Product/Service**\\n   * Objective: operate in production for years.\\n   * Requires:\\n     * clear SLOs/SLAs,\\n     * serious pipelines,\\n     * reliability metrics,\\n     * evolution strategy.\\n\\nThe PoC \u2192 product jump **without an intermediate phase** is what so often ends in technical debt nightmare.\\n\\n## What You Can Do as a Dev/Architect (Even If You\'re Not \\"CTO\\")\\n\\nSome very concrete actions you can incorporate into your daily practice:\\n\\n* **Put language to shortcuts**\\n  When someone asks \\"do it quickly\\":\\n  * \\"Okay, but that implies technical debt of type X. We accept it if we then dedicate Y hours to cleaning it up\\".\\n\\n* **Visualize complexity**\\n  * Simple diagrams (C4 level 1\u20132) to show when the architecture is becoming absurd for the product size.\\n\\n* **Measure the pain**\\n  * \\"Every change in this module takes us two weeks and breaks three things\\".\\n  * That opens doors to propose refactors, simplification, or re-architecture.\\n\\n* **Negotiate conditions for a PoC**\\n  * Clear timebox.\\n  * What can be sacrificed (performance, internal cleanliness) and what CANNOT (basic security, privacy, data integrity).\\n\\n## Conclusion: Engineering \u2260 Dogma, It\'s Managing Trade-offs\\n\\nNot every project deserves a textbook architecture, nor is anything acceptable with \\"it\'s just a test\\". Both extremes are, fundamentally, **lack of engineering**:\\n\\n* Over-engineering ignores the real cost of complexity.\\n* Eternal PoC culture ignores the real cost of technical debt.\\n\\nReal software engineering is about this:\\n\\n> **Making explicit decisions about where you accept complexity and where you accept debt, with a plan to manage both over time.**\\n\\nIf you take one thing from this post, let it be this idea:\\n\\n* When you\'re going to design: ask yourself *\\"can I make it simpler without losing the essential?\\"*.\\n* When you\'re going to \\"do something quick\\": ask yourself *\\"am I willing to pay the price of leaving it like this?\\"*.\\n\\nYou won\'t find the balance in any book: you\'ll build it yourself, project by project, decision by decision.\\n\\n---\\n\\n## References\\n\\n* [KISS vs. DRY vs. YAGNI: Understanding Key Software Development Principles](https://rrmartins.medium.com/kiss-vs-dry-vs-yagni-understanding-key-software-development-principles-e307b7419636)\\n* [Technical Debt Quadrant - Martin Fowler](https://martinfowler.com/bliki/TechnicalDebtQuadrant.html)\\n* [When Proof of Concepts Become Production Code](https://blog.scaledcode.com/blog/poc-to-production/)\\n* [YAGNI - Martin Fowler](https://martinfowler.com/bliki/Yagni.html)"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","source":"@site/blog/2025-11-15-welcome.md","title":"Welcome to my blog!","description":"Hello and welcome to my personal blog! \ud83d\udc4b","date":"2025-11-15T00:00:00.000Z","tags":[{"inline":false,"label":"Personal","permalink":"/blog/tags/personal","description":"Personal posts"}],"readingTime":1.07,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"welcome","title":"Welcome to my blog!","authors":["valdepeace"],"tags":["personal"]},"unlisted":false,"prevItem":{"title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","permalink":"/blog/over-engineering-vs-poc"}},"content":"Hello and welcome to my personal blog! \ud83d\udc4b\\n\\nThis is the first post of many to come. Here I\'ll share my experiences, learnings, and reflections about technology, software development, and everything I\'m passionate about.\\n\\n\x3c!--truncate--\x3e\\n\\n## What will you find here?\\n\\nIn this space I\'ll publish content about:\\n\\n- **\ud83d\udcbb Web Development:** Tutorials, tips, and best practices\\n- **\ud83d\ude80 Modern Technologies:** React, TypeScript, Node.js, and more\\n- **\ud83d\udcda Learnings:** Experiences and lessons learned\\n- **\ud83d\udd27 Tools:** Reviews and guides for useful tools\\n- **\ud83d\udca1 Ideas:** Reflections about the tech industry\\n\\n## My vision\\n\\nI firmly believe in sharing knowledge. The developer community has been incredibly generous with me, and this is my way of giving back a little of what I\'ve received.\\n\\nDon\'t expect perfect posts, but honest, practical, and useful content based on real experiences.\\n\\n## What\'s coming?\\n\\nIn the upcoming posts I\'ll talk about:\\n\\n- How I set up this site with Docusaurus\\n- Best practices in React and TypeScript\\n- Tools I use daily\\n- Projects I\'m working on\\n\\n## Stay connected\\n\\nIf you\'re interested in the content, you can:\\n\\n- Subscribe to the [RSS feed](/blog/rss.xml)\\n- Follow me on [Twitter](https://twitter.com/valdepeace)\\n- Connect on [LinkedIn](https://www.linkedin.com/in/valdepeace)\\n- See my work on [GitHub](https://github.com/valdepeace)\\n\\nThanks for being here! \ud83d\ude80\\n\\n---\\n\\n*Do you have any topic you\'d like me to cover? Leave me a comment or contact me!*"}]}}')}}]);