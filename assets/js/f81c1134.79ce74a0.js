"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2025/12/02/arquitectura-de-carton-piedra","metadata":{"permalink":"/blog/2025/12/02/arquitectura-de-carton-piedra","source":"@site/blog/2025-12-02-arquitectura-de-carton-piedra.md","title":"Arquitectura de cart\xf3n piedra: cuando el c\xf3digo parece limpio, pero no hay quien lo entienda","description":"Qu\xe9 es la arquitectura de cart\xf3n piedra, por qu\xe9 aparece y c\xf3mo mejorarla sin reescribir todo.","date":"2025-12-02T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture","description":"Software architecture"},{"inline":true,"label":"refactor","permalink":"/blog/tags/refactor"},{"inline":false,"label":"Best Practices","permalink":"/blog/tags/best-practices","description":"Software development best practices"}],"readingTime":5.48,"hasTruncateMarker":false,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"title":"Arquitectura de cart\xf3n piedra: cuando el c\xf3digo parece limpio, pero no hay quien lo entienda","description":"Qu\xe9 es la arquitectura de cart\xf3n piedra, por qu\xe9 aparece y c\xf3mo mejorarla sin reescribir todo.","authors":["valdepeace"],"date":"2025-12-02","tags":["architecture","refactor","best-practices"]},"unlisted":false,"nextItem":{"title":"Cardboard Architecture: when code looks clean but nobody understands it","permalink":"/blog/2025/12/02/cardboard-architecture"}},"content":"## Arquitectura de cart\xf3n piedra: cuando el c\xf3digo parece limpio, pero no hay quien lo entienda\\n\\nHay proyectos que, al abrirlos, dan muy buena impresi\xf3n:\\n\\n* Carpetas bien puestas: `core`, `domain`, `infrastructure`, `services`, `helpers`\u2026\\n* Clases con nombres serios: `UserService`, `OrderManager`, `PaymentHandler`\u2026\\n* Documentaci\xf3n extensa, diagramas, README detallado\u2026\\n\\nY sin embargo, cuando intentas seguir **c\xf3mo funciona realmente el sistema**, te encuentras con algo muy distinto:\\nm\xe9todos que llaman a otros m\xe9todos que llaman a otros m\xe9todos, capas que solo delegan, l\xf3gica de negocio repartida por todo el repositorio\u2026 y t\xfa pensando:\\n\\n> \u201cEsto parece muy arquitect\xf3nico, pero entenderlo es un dolor.\u201d\\n\\nA eso es a lo que me gusta llamar **arquitectura de cart\xf3n piedra**: por fuera parece s\xf3lida, pero por dentro no sostiene bien el peso del negocio.\\n\\n---\\n\\n## \xbfQu\xe9 es la \u201carquitectura de cart\xf3n piedra\u201d?\\n\\nNo es un t\xe9rmino oficial, pero describe muy bien una situaci\xf3n bastante com\xfan:\\n\\n> **Arquitectura de cart\xf3n piedra**: cuando se construye una estructura de carpetas y capas que *simula* una arquitectura limpia, pero en la pr\xe1ctica no ayuda a entender el flujo ni a mantener el sistema.\\n\\nAlgunos s\xedntomas t\xedpicos:\\n\\n* Abres el proyecto y ves mil capas, pero **no sabes d\xf3nde vive el negocio**.\\n* Para seguir un caso de uso sencillo (por ejemplo, crear un pedido) tienes que abrir **8\u201310 ficheros**.\\n* La mayor\xeda de las clases son **pasamanos**:\\n\\n  * `Controller` \u2192 `Manager` \u2192 `Handler` \u2192 `Service` \u2192 `Processor` \u2192 `Repository`\u2026\\n    y cada uno solo delega al siguiente.\\n* La l\xf3gica de negocio est\xe1 **fragmentada**:\\n\\n  * un trozo en el controller,\\n  * otro en un helper,\\n  * otro en el repositorio,\\n  * otro en un \u201cutil\u201d gen\xe9rico.\\n\\nPuede haber documentaci\xf3n muy buena\u2026\\npero si la estructura del c\xf3digo no refleja bien el negocio, **la arquitectura no est\xe1 cumpliendo su funci\xf3n**.\\n\\n---\\n\\n## \xbfPor qu\xe9 pasa esto?\\n\\nNormalmente se mezclan varias cosas:\\n\\n1. **Dise\xf1ar por carpeta, no por dominio**\\n   Se copia una estructura \u201cde libro\u201d (o de otro proyecto) sin pensar si encaja con el negocio real.\\n\\n2. **Confundir \u201cm\xe1s capas\u201d con \u201cmejor arquitectura\u201d**\\n\\n   * Se a\xf1aden capas tipo `Manager`, `Handler`, `Processor`, etc.\\n   * Pero muchas veces esas capas no encapsulan nada nuevo, solo complican el recorrido.\\n\\n3. **Cargo cult de patrones**\\n   Se aplican etiquetas como \u201cClean Architecture\u201d, \u201cDDD\u201d, \u201cHexagonal\u201d\u2026\\n   pero solo en lo superficial: nombres de carpetas y clases, sin respetar los principios.\\n\\n4. **Miedo a equivocarse**\\n   Se crean capas \u201cpor si acaso las necesitamos luego\u201d,\\n   y al final se acumulan niveles de indirecci\xf3n innecesarios.\\n\\n---\\n\\n\\n## C\xf3mo se vive trabajar en un proyecto as\xed\\n\\nSi has ca\xeddo en uno de estos proyectos, probablemente te suena:\\n\\n* Para hacer un cambio peque\xf1o tienes que tocar c\xf3digo en **medio repositorio**.\\n* No est\xe1 claro d\xf3nde **deber\xeda** ir una nueva regla de negocio.\\n* Refactorizar da miedo porque no entiendes bien el flujo completo.\\n* La documentaci\xf3n se vuelve obligatoria porque el c\xf3digo, por s\xed solo, **no se explica**.\\n\\nUna arquitectura sana deber\xeda ser casi lo contrario:\\n\\n> Aunque no haya documentaci\xf3n perfecta,\\n> deber\xedas intuir d\xf3nde est\xe1n las cosas con solo ver la estructura b\xe1sica.\\n\\n---\\n\\n## \xbfC\xf3mo es una arquitectura que ayuda de verdad?\\n\\nUna buena arquitectura no va de tener muchas capas, sino de que:\\n\\n### 1. El flujo sea f\xe1cil de seguir\\n\\nEjemplo muy simple:\\n\\n```text\\nHTTP Request \u2192 Controller \u2192 Caso de uso \u2192 Repositorios/Adaptadores \u2192 Respuesta\\n```\\n\\nEs decir, puedes explicar qu\xe9 pasa con una frase y unos pocos ficheros.\\n\\n### 2. La l\xf3gica de negocio est\xe9 concentrada en sitios previsibles\\n\\nPor ejemplo:\\n\\n* `CreateOrderUseCase`\\n* `ReserveSeatService`\\n* `CalculatePriceDomainService`\\n\\nY no escondida en helpers gen\xe9ricos o en m\xe9todos random de un repositorio.\\n\\n### 3. Las capas existan por una raz\xf3n clara\\n\\nUn esquema t\xedpico (y suficiente en muchos casos) podr\xeda ser:\\n\\n* **Interface / API**: controllers, DTOs, validaciones de entrada.\\n* **Application**: casos de uso, orquestaci\xf3n de procesos.\\n* **Domain**: entidades, reglas de negocio puras.\\n* **Infrastructure**: repositorios, acceso a bases de datos, APIs externas, colas, etc.\\n\\nLa clave es que, si alguien te pregunta:\\n\\n> \u201c\xbfD\xf3nde est\xe1 la l\xf3gica de *reservar un curso*?\u201d\\n\\npuedas responder algo tipo:\\n\\n> \u201cMira en `application/ReserveCourse.ts` y en `domain/CourseReservation`.\u201d\\n\\nSin tener que hacer un *\u201cbuscar en todo el repo\u201d*.\\n\\n---\\n\\n## Checklist r\xe1pido: \xbfhuele a cart\xf3n piedra?\\n\\nAlgunas preguntas \xfatiles cuando revisas un proyecto:\\n\\n1. **\xbfCu\xe1ntos ficheros tengo que abrir para seguir un caso de uso sencillo?**\\n\\n   * Si son m\xe1s de 5\u20136, sospecha.\\n2. **\xbfCu\xe1ntas clases solo delegan sin a\xf1adir l\xf3gica nueva?**\\n\\n   * Si la mayor\xeda son \u201cpasamanos\u201d, sobran capas.\\n3. **\xbfS\xe9 claramente d\xf3nde vive el negocio?**\\n\\n   * \xbfHay un sitio claro para los casos de uso?\\n4. **\xbfLa estructura est\xe1 basada en \u201cfeatures\u201d o en \u201ccapas gen\xe9ricas\u201d?**\\n\\n   * `orders/`, `payments/`, `users/` suele ser m\xe1s \xfatil que\\n     `managers/`, `helpers/`, `processors/`.\\n5. **\xbfQu\xe9 pasa si el \u201cdesarrollador h\xe9roe\u201d no est\xe1?**\\n\\n   * \xbfEl equipo puede mantener el sistema sin \xe9l/ella?\\n\\nCuantas m\xe1s respuestas inc\xf3modas, m\xe1s probable que est\xe9s delante de una arquitectura de cart\xf3n piedra.\\n\\n---\\n\\n## C\xf3mo mejorar sin reescribirlo todo\\n\\nNo siempre puedes tirar el proyecto y empezar de cero (de hecho, casi nunca).\\nPero s\xed puedes **mejorar poco a poco**:\\n\\n### 1. Elegir un caso de uso clave y mapearlo\\n\\nPor ejemplo: \u201ccrear pedido\u201d.\\n\\n* Dibuja el flujo actual (aunque sea en un papel) desde el endpoint hasta la base de datos.\\n* Identifica capas que no aportan nada.\\n\\n### 2. Concentrar la l\xf3gica de negocio\\n\\n* Crea un `CreateOrderUseCase` o similar.\\n* Ve moviendo reglas dispersas (en controller, helpers, etc.) hacia ese caso de uso.\\n\\n### 3. Eliminar pasamanos innecesarios\\n\\n* Si un `Manager` solo llama a un `Service` sin a\xf1adir nada, fusi\xf3nalos.\\n* Menos capas, m\xe1s claridad.\\n\\n### 4. Nombrar por dominio, no por patr\xf3n\\n\\nMejor:\\n\\n* `AssignSeatToPassenger`\\n* `CalculateInvoiceTotals`\\n\\nque:\\n\\n* `SeatManager`\\n* `InvoiceProcessor`\\n\\n### 5. Documentar el flujo, no solo la arquitectura\\n\\nUn diagrama sencillo del tipo:\\n\\n```mermaid\\nflowchart LR\\n  A[HTTP Request] --\x3e B[OrderController]\\n  B --\x3e C[CreateOrderUseCase]\\n  C --\x3e D[OrderRepository]\\n```\\n\\nvale oro si realmente refleja lo que pasa.\\n\\n---\\n\\n## Cerrar el c\xedrculo\\n\\nAl final, la reflexi\xf3n es sencilla:\\n\\n* **Arquitectura no es cu\xe1ntas carpetas tienes**,\\n  sino cu\xe1nto te ayuda a pensar y cambiar el negocio.\\n* Documentar est\xe1 genial, pero la mejor documentaci\xf3n es un c\xf3digo y una estructura\\n  que \u201cse explican solos\u201d.\\n* Y un desarrollador realmente senior no es solo el que desarrolla r\xe1pido,\\n  sino el que deja un sistema que cualquier persona del equipo puede entender y seguir ampliando.\\n\\nSi al abrir un proyecto tienes la sensaci\xf3n de que todo est\xe1 muy \u201cbonito\u201d, pero **no puedes seguir el flujo sin sufrir**, probablemente no eres t\xfa: es cart\xf3n piedra.\\n\\nY la buena noticia es que, en cuanto empiezas a desarrollar ese olfato, tambi\xe9n empiezas a dise\xf1ar tus propios proyectos de forma distinta: menos postureo, m\xe1s claridad, m\xe1s negocio\u2026 y menos dolor para el siguiente que venga detr\xe1s (aunque ese siguiente seas t\xfa dentro de seis meses).\\n\\n---\\n\\nSi quieres, en otro post podemos hacer el \u201cmodo pr\xe1ctico\u201d: coger un caso de uso real tuyo y ense\xf1ar un *antes vs despu\xe9s* de refactor, con c\xf3digo."},{"id":"/2025/12/02/cardboard-architecture","metadata":{"permalink":"/blog/2025/12/02/cardboard-architecture","source":"@site/blog/2025-12-02-cardboard-architecture.md","title":"Cardboard Architecture: when code looks clean but nobody understands it","description":"What \'cardboard architecture\' is, why it appears, and how to improve it without rewriting everything.","date":"2025-12-02T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture","description":"Software architecture"},{"inline":true,"label":"refactor","permalink":"/blog/tags/refactor"},{"inline":false,"label":"Best Practices","permalink":"/blog/tags/best-practices","description":"Software development best practices"}],"readingTime":4.97,"hasTruncateMarker":false,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"title":"Cardboard Architecture: when code looks clean but nobody understands it","description":"What \'cardboard architecture\' is, why it appears, and how to improve it without rewriting everything.","authors":["valdepeace"],"date":"2025-12-02","tags":["architecture","refactor","best-practices"]},"unlisted":false,"prevItem":{"title":"Arquitectura de cart\xf3n piedra: cuando el c\xf3digo parece limpio, pero no hay quien lo entienda","permalink":"/blog/2025/12/02/arquitectura-de-carton-piedra"},"nextItem":{"title":"Mastra vs Agent Framework + Azure AI Foundry","permalink":"/blog/mastra-vs-microsoft-agent-framework"}},"content":"## Cardboard Architecture: when code looks clean but nobody understands it\\n\\nSome projects give a great first impression when you open them:\\n\\n* Well-organized folders: `core`, `domain`, `infrastructure`, `services`, `helpers`\u2026\\n* Classes with serious names: `UserService`, `OrderManager`, `PaymentHandler`\u2026\\n* Extensive documentation, diagrams, detailed README\u2026\\n\\nAnd yet, when you try to follow **how the system actually works**, you find something very different:\\nmethods calling other methods calling other methods, layers that only delegate, business logic scattered across the repository\u2026 and you thinking:\\n\\n> \u201cThis looks architectural, but understanding it is painful.\u201d\\n\\nThat\u2019s what I like to call **cardboard architecture**: it looks solid on the outside but doesn\u2019t really hold the weight of the business inside.\\n\\n---\\n\\n## What is \u201ccardboard architecture\u201d?\\n\\nIt\u2019s not an official term, but it describes a very common situation well:\\n\\n> **Cardboard architecture**: when you build a folder-and-layer structure that *simulates* clean architecture, but in practice doesn\u2019t help you understand the flow or maintain the system.\\n\\nTypical symptoms:\\n\\n* You open the project and see a thousand layers, but **you don\u2019t know where the business logic lives**.\\n* To follow a simple use case (e.g., create an order) you need to open **8\u201310 files**.\\n* Most classes are **pass-throughs**:\\n\\n  * `Controller` \u2192 `Manager` \u2192 `Handler` \u2192 `Service` \u2192 `Processor` \u2192 `Repository`\u2026\\n    and each one just delegates to the next.\\n* Business logic is **fragmented**:\\n\\n  * a bit in the controller,\\n  * another in a helper,\\n  * another in the repository,\\n  * another in a generic `util`.\\n\\nThere may be excellent documentation\u2026\\nbut if the code structure doesn\u2019t reflect the business, **the architecture fails its purpose**.\\n\\n---\\n\\n## Why does this happen?\\n\\nUsually several things mix together:\\n\\n1. **Designing by folder, not by domain**\\n   Copying a \u201ctextbook\u201d structure (or another project) without thinking if it fits the real business.\\n\\n2. **Confusing \u201cmore layers\u201d with \u201cbetter architecture\u201d**\\n\\n   * Adding layers like `Manager`, `Handler`, `Processor`, etc.\\n   * But often those layers don\u2019t encapsulate anything new, they just complicate the path.\\n\\n3. **Cargo-culting patterns**\\n   Applying labels like \u201cClean Architecture\u201d, \u201cDDD\u201d, \u201cHexagonal\u201d\u2026\\n   but only superficially: folder and class names, not the principles.\\n\\n4. **Fear of being wrong**\\n   Creating layers \u201cin case we need them later\u201d,\\n   and ending up with accumulated unnecessary indirection levels.\\n\\n---\\n\\n\\n## What it feels like to work on such a project\\n\\nIf you\u2019ve landed in one of these projects, this will sound familiar:\\n\\n* To make a small change you have to touch code across **half the repo**.\\n* It\u2019s unclear where a new business rule **should** live.\\n* Refactoring is scary because you don\u2019t fully understand the whole flow.\\n* Documentation becomes mandatory because the code alone **doesn\u2019t explain itself**.\\n\\nA healthy architecture should be almost the opposite:\\n\\n> Even without perfect docs,\\n> you should be able to guess where things live just by looking at the basic structure.\\n\\n---\\n\\n## What does an actually helpful architecture look like?\\n\\nGood architecture isn\u2019t about having many layers, it\u2019s about:\\n\\n### 1. The flow being easy to follow\\n\\nVery simple example:\\n\\n```text\\nHTTP Request \u2192 Controller \u2192 Use Case \u2192 Repositories/Adapters \u2192 Response\\n```\\n\\nMeaning you can explain what happens in one sentence and a few files.\\n\\n### 2. Business logic concentrated in predictable places\\n\\nFor example:\\n\\n* `CreateOrderUseCase`\\n* `ReserveSeatService`\\n* `CalculatePriceDomainService`\\n\\nNot hidden in generic helpers or random repository methods.\\n\\n### 3. Layers existing for a clear reason\\n\\nA typical (and often sufficient) layout could be:\\n\\n* **Interface / API**: controllers, DTOs, input validation.\\n* **Application**: use cases, process orchestration.\\n* **Domain**: entities, pure business rules.\\n* **Infrastructure**: repositories, DB access, external APIs, queues, etc.\\n\\nThe key is that if someone asks:\\n\\n> \u201cWhere is the logic to *reserve a course*?\u201d\\n\\nyou can answer:\\n\\n> \u201cLook in `application/ReserveCourse.ts` and `domain/CourseReservation`.\u201d\\n\\nwithout doing a repo-wide search.\\n\\n---\\n\\n## Quick checklist: does it smell like cardboard architecture?\\n\\nSome useful questions when reviewing a project:\\n\\n1. **How many files do I need to open to follow a simple use case?**\\n\\n   * If more than 5\u20136, be suspicious.\\n2. **How many classes only delegate without adding logic?**\\n\\n   * If most are passthroughs, you have too many layers.\\n3. **Do I clearly know where the business lives?**\\n\\n   * Is there a clear place for use cases?\\n4. **Is the structure feature-based or generic layers-based?**\\n\\n   * `orders/`, `payments/`, `users/` is often more useful than\\n     `managers/`, `helpers/`, `processors/`.\\n5. **What happens if the \u201chero developer\u201d is not available?**\\n\\n   * Can the team maintain the system without them?\\n\\nThe more uncomfortable answers, the more likely you\u2019re facing cardboard architecture.\\n\\n---\\n\\n## How to improve without rewriting everything\\n\\nYou rarely can throw away the project and start over (in fact, almost never).\\nBut you can **improve incrementally**:\\n\\n### 1. Pick a key use case and map it\\n\\nExample: \u201ccreate order\u201d.\\n\\n* Draw the current flow (even on paper) from endpoint to DB.\\n* Identify layers that contribute nothing.\\n\\n### 2. Concentrate business logic\\n\\n* Create a `CreateOrderUseCase` or similar.\\n* Move scattered rules (in controllers, helpers, etc.) into that use case.\\n\\n### 3. Remove unnecessary pass-throughs\\n\\n* If a `Manager` only calls a `Service` without adding value, merge them.\\n* Fewer layers, more clarity.\\n\\n### 4. Name by domain, not by pattern\\n\\nBetter:\\n\\n* `AssignSeatToPassenger`\\n* `CalculateInvoiceTotals`\\n\\nthan:\\n\\n* `SeatManager`\\n* `InvoiceProcessor`\\n\\n### 5. Document the flow, not only the architecture\\n\\nA simple diagram like:\\n\\n```mermaid\\nflowchart LR\\n  A[HTTP Request] --\x3e B[OrderController]\\n  B --\x3e C[CreateOrderUseCase]\\n  C --\x3e D[OrderRepository]\\n```\\n\\nis gold if it truly reflects what happens.\\n\\n---\\n\\n## Closing the loop\\n\\nThe takeaway is simple:\\n\\n* **Architecture is not how many folders you have**,\\n  it\u2019s how much it helps you think about and change the business.\\n* Documentation is great, but the best documentation is code and structure that \u201cexplain themselves\u201d.\\n* A truly senior developer is not just fast,\\n  but the one who leaves a system any teammate can understand and extend.\\n\\nIf a project looks pretty but you **can\u2019t** follow the flow without suffering, it\u2019s probably not you: it\u2019s cardboard.\\n\\nAnd the good news: once you develop that sense, you start designing your own projects differently: less posture, more clarity, more business focus\u2026 and less pain for whoever comes next (even if that\u2019s you in six months).\\n\\n---\\n\\nIf you want, in another post we can do the \u201cpractical mode\u201d: take a real use case of yours and show a before vs after refactor, with code."},{"id":"mastra-vs-microsoft-agent-framework","metadata":{"permalink":"/blog/mastra-vs-microsoft-agent-framework","source":"@site/blog/2025-11-29-mastra-vs-microsoft-agent-framework.md","title":"Mastra vs Agent Framework + Azure AI Foundry","description":"Two ways to build production AI agents","date":"2025-11-29T00:00:00.000Z","tags":[{"inline":false,"label":"Mastra","permalink":"/blog/tags/mastra","description":"Mastra TypeScript agent framework"},{"inline":false,"label":"Microsoft Agent Framework","permalink":"/blog/tags/microsoft-agent-framework","description":"Microsoft Agent Framework and Azure AI Foundry"},{"inline":false,"label":"Comparison","permalink":"/blog/tags/comparison","description":"Comparative articles"},{"inline":false,"label":"AI Agents","permalink":"/blog/tags/ai-agents","description":"Agent frameworks and AI agents"}],"readingTime":6.07,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"mastra-vs-microsoft-agent-framework","title":"Mastra vs Agent Framework + Azure AI Foundry","authors":["valdepeace"],"tags":["mastra","microsoft-agent-framework","comparison","ai-agents"]},"unlisted":false,"prevItem":{"title":"Cardboard Architecture: when code looks clean but nobody understands it","permalink":"/blog/2025/12/02/cardboard-architecture"},"nextItem":{"title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","permalink":"/blog/over-engineering-vs-poc"}},"content":"## Two ways to build production AI agents\\n\\nIn recent months many frameworks for building AI agents have emerged. Two approaches I find particularly interesting are:\\n\\n- **Mastra**, an all-TypeScript agent framework that feels natural if your stack is Node-based.\\n- **Microsoft Agent Framework + Azure AI Foundry (Azure AI Agents)**, Microsoft\'s offering that pairs an orchestration library with a managed agent service on Azure.\\n\\nAt first glance they look like different worlds, but they share a similar mental model: agents that keep conversations via threads/sessions, messages, and runs.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n## 1. Shared mental model: agents, threads and runs\\n\\nBoth Mastra and Microsoft\'s stack can be understood with the same pattern:\\n\\n- **Agent**: A virtual \u201cperson\u201d with instructions, a model, tools and memory.\\n- **Thread / Session**: A conversation thread that preserves context.\\n- **Messages**: Exchanges between `user` and `assistant`.\\n- **Run**: A specific execution of an agent against a conversation.\\n\\nThe difference is less about concepts and more about where that state machine lives:\\n\\n- In **Mastra**, the state machine runs in your backend (Node/TS).\\n- In **Azure AI Agents**, the state machine lives in a **managed Azure service**.\\n\\n---\\n\\n## 2. What is Mastra?\\n\\nIn short:\\n\\n- It\'s an **agent framework in TypeScript**: agents, tools, workflows (flows/graphs), RAG, tracing and evals (Mastra Cloud).\\n- The **runtime** runs in your Node app (Express, Next.js, Lambdas, Functions, etc.).\\n- It integrates well with the JS/TS ecosystem: static typing, nice DX, a CLI and a dev server.\\n\\nThink of Mastra as an **all-in-one TypeScript-first agent platform**: runtime + agents + tools + workflows + tracing, all expressed in code.\\n\\n---\\n\\n## 3. What is Agent Framework + Azure AI Foundry?\\n\\nIn this stack the pieces are split into two complementary parts:\\n\\n### Microsoft Agent Framework\\n\\n- A library to **orchestrate agents and workflows** in .NET or Python.\\n- It lets you define graphs, steps, states, multi-agent scenarios, etc.\\n- You provide the runtime: App Service, Functions, Container Apps, AKS, and so on.\\n\\n### Azure AI Foundry / Azure AI Agents\\n\\n- A managed service that hosts agents (model + instructions + tools + memory), threads (conversations) and runs (executions).\\n- Consumed via SDKs (`@azure/ai-agents`, `azure-ai-agents`) or REST.\\n- Deeply integrated with the Foundry ecosystem: model deployments, AI Search, Fabric, Storage, etc.\\n\\nTogether they cover similar functionality to Mastra, but as **two complementary pieces** rather than a single all-in-one package.\\n\\n---\\n\\n## 4. High-level comparison\\n\\n| Aspect | Mastra | Agent Framework + Azure Foundry |\\n|---|---|---|\\n| Product type | TypeScript framework + observability (Mastra Cloud) | Orchestration library (.NET/Python) + managed service |\\n| Primary language | TypeScript / Node | .NET / Python (SDKs available) |\\n| Where runtime lives | In your backend (Node, Lambdas, Functions, etc.) | In your code + managed Azure agent service |\\n| Conversation unit | Session / conversationId | Thread |\\n| Executions | Runs / traces in your app + Mastra Cloud | Runs managed by the agent service |\\n| Primary models | Any provider supported by Mastra | Models from Azure catalog |\\n| Tools | JS/TS functions, HTTP, DB, MCP\u2026 | Native tools + OpenAPI/HTTP + function tools |\\n| Lock-in | Low (mostly depends on chosen LLM) | Medium/high (tied to Azure Foundry) |\\n| Azure integration | Via SDKs / standard APIs | Native (AI Search, Fabric, Storage, Monitor) |\\n| JS/TS learning curve | Very low | Medium (if also orchestrating with .NET/Python) |\\n\\n---\\n\\n## 5. DX: what it is and why it matters\\n\\nDX = Developer Experience. This includes how easy it is to get started, API clarity, type/autocomplete support, CLI and documentation.\\n\\n- For Node/TypeScript teams, Mastra\'s DX tends to feel natural.\\n- Microsoft\'s stack offers strong DX for .NET/Python and adds value if you\'re already deep in Azure, but it also introduces more mental models: Foundry projects, managed agents, Agent Framework, etc.\\n\\n---\\n\\n## 6. Pros and cons\\n\\n### Mastra\\n\\n#### Pros \u2014 Mastra\\n\\n- TypeScript-first: fits perfectly in modern Node stacks.\\n- Runtime under your control (`execute`, workflows in TS).\\n- Multi-provider model support.\\n- Natural integration with HTTP, DBs, MCP, etc.\\n- Good DX: CLI, dev server, tracing and evals in Mastra Cloud.\\n\\n#### Cons \u2014 Mastra\\n\\n- You must operate the infrastructure (Kubernetes, Functions, etc.).\\n- You handle enterprise governance/compliance yourself.\\n- No built-in, native Azure integrations by default.\\n\\n---\\n\\n### Agent Framework + Azure Foundry\\n\\n#### Pros \u2014 Agent Framework + Foundry\\n\\n- Managed agent service for threads/runs/state and scaling.\\n- Native integration with AI Search, Fabric, OneLake, Storage.\\n- Enterprise security and governance (Entra ID, Monitor, Defender).\\n- Native tools and OpenAPI/HTTP support.\\n\\n#### Cons \u2014 Agent Framework + Foundry\\n\\n- Platform lock-in: Foundry and its resources.\\n- Agent Framework is .NET/Python (no TS runtime like Mastra).\\n- The runs/threads model may be less flexible than running everything in TS.\\n\\n---\\n\\n## 7. Architecture diagrams\\n\\n### 7.1. Mastra-centric approach\\n\\n```mermaid\\nflowchart LR\\n  UI[Web/App] --\x3e|HTTP| MAS[Mastra Agents & Workflows]\\n  MAS --\x3e GATEWAY[LLM Gateway]\\n  GATEWAY --\x3e P1[Provider 1]\\n  GATEWAY --\x3e P2[Provider 2]\\n```\\n\\n### 7.2. Azure-centric approach\\n\\n```mermaid\\nflowchart LR\\n  UI --\x3e|HTTP| WF[Orchestrator (.NET/Python)]\\n  WF --\x3e|SDK/REST| AGENT[Azure Agent Service]\\n  AGENT --\x3e TOOLS[AI Search / Fabric / Storage]\\n```\\n\\n### 7.3. Hybrid approach\\n\\n```mermaid\\nflowchart LR\\n  UI --\x3e MAS[Mastra]\\n  MAS --\x3e GATEWAY\\n  MAS --\x3e AZ_TOOL[Tool: Azure Agent Service]\\n  AZ_TOOL --\x3e AZ_AGENT\\n```\\n\\n---\\n\\n## 8. Quick example: a TS agent delegating to Azure\\n\\nHybrid pattern: keep a primary agent in Mastra and give it a tool that calls a managed Azure agent.\\n\\n```ts\\n// azureAgentTool.ts\\nimport { AgentsClient } from \\"@azure/ai-agents\\";\\nimport { DefaultAzureCredential } from \\"@azure/identity\\";\\n\\nconst projectEndpoint = process.env.PROJECT_ENDPOINT!;\\nconst azureAgentId = process.env.AZURE_AGENT_ID!;\\n\\nconst agentsClient = new AgentsClient(\\n  projectEndpoint,\\n  new DefaultAzureCredential(),\\n);\\n\\nexport async function callAzureAgent(input: string): Promise<string> {\\n  const thread = await agentsClient.threads.create();\\n  await agentsClient.messages.create(thread.id, \\"user\\", input);\\n  const run = await agentsClient.runs.createAndPoll(thread.id, { agentId: azureAgentId });\\n  if (run.status !== \\"succeeded\\") throw new Error(`Azure agent run failed: ${run.status}`);\\n  let lastAnswer = \\"\\";\\n  for await (const msg of agentsClient.messages.list(thread.id)) {\\n    if (msg.role === \\"assistant\\") {\\n      const first = msg.content?.[0];\\n      if (first && (first as any).text) lastAnswer = (first as any).text;\\n    }\\n  }\\n  return lastAnswer || \\"The Azure agent did not return a text response.\\";\\n}\\n```\\n\\n```ts\\n// hybridAgent.ts (sketch)\\nimport { createAgent } from \\"mastra\\";\\nimport { callAzureAgent } from \\"./azureAgentTool\\";\\n\\nexport const hybridAgent = createAgent({\\n  name: \\"hybrid-agent\\",\\n  instructions: \\"You are an assistant that decides when to delegate queries to Azure.\\",\\n  model: { provider: \\"openai\\", name: \\"gpt-4o-mini\\" },\\n  tools: {\\n    askAzure: {\\n      description: \\"Use this tool to query the Azure agent\\",\\n      execute: async ({ query }: { query: string }) => ({ answer: await callAzureAgent(query) }),\\n    },\\n  },\\n});\\n```\\n\\n---\\n\\n## 9. Key idea: orchestration matters most\\n\\nBeyond choosing Mastra or Agent Framework + Foundry, the important part is **how you orchestrate your agents around business logic** and **how you manage conversational state**.\\n\\nMastra is an all-in-one TypeScript solution; in the Microsoft ecosystem you get Agent Framework (the orchestrator) + Foundry (the managed runtime). Often a hybrid combination delivers the best of both.\\n\\n---\\n\\n## 10. Conclusion\\n\\n- If your team lives in TypeScript, start with Mastra to iterate quickly.\\n- If your organization requires Azure-level governance and deep integration, use Agent Framework + Foundry.\\n- Often the most valuable approach is a combination: Mastra for product-layer agility and Foundry for specialist data/governance capabilities.\\n\\nIf you\'d like, I can create a short LinkedIn-ready version with the comparison table and the hybrid diagram.\\n\\n---\\n\\n## References\\n\\n- Mastra documentation \u2014 [https://mastra.ai/docs](https://mastra.ai/docs)\\n- Mastra GitHub \u2014 [https://github.com/mastra-ai/mastra](https://github.com/mastra-ai/mastra)\\n- Mastra Book (Principles of Building AI Agents) \u2014 [https://mastra.ai/book](https://mastra.ai/book)\\n- Mastra Templates \u2014 [https://mastra.ai/templates](https://mastra.ai/templates)\\n- Azure AI Foundry (Microsoft Learn) \u2014 [https://learn.microsoft.com/en-us/azure/ai-foundry/](https://learn.microsoft.com/en-us/azure/ai-foundry/)\\n- Azure AI Agents SDK (`@azure/ai-agents`) \u2014 [https://www.npmjs.com/package/@azure/ai-agents](https://www.npmjs.com/package/@azure/ai-agents)\\n- Azure Identity (`@azure/identity`) \u2014 [https://www.npmjs.com/package/@azure/identity](https://www.npmjs.com/package/@azure/identity)\\n- Azure AI & general docs \u2014 [https://learn.microsoft.com/azure](https://learn.microsoft.com/azure)"},{"id":"over-engineering-vs-poc","metadata":{"permalink":"/blog/over-engineering-vs-poc","source":"@site/blog/2025-11-16-over-engineering-vs-poc.md","title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","description":"In recent years, I\'ve seen two equally damaging extremes in many development teams: over-engineering and the eternal PoC culture. This post is about why both extremes are bad engineering practices and how to find a reasonable middle ground.","date":"2025-11-16T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture","description":"Software architecture"},{"inline":false,"label":"Best Practices","permalink":"/blog/tags/best-practices","description":"Software development best practices"},{"inline":false,"label":"Software Engineering","permalink":"/blog/tags/software-engineering","description":"Software engineering principles and practices"},{"inline":false,"label":"Technical Debt","permalink":"/blog/tags/technical-debt","description":"Technical debt management"}],"readingTime":6.54,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"over-engineering-vs-poc","title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","authors":["valdepeace"],"tags":["architecture","best-practices","software-engineering","technical-debt"]},"unlisted":false,"prevItem":{"title":"Mastra vs Agent Framework + Azure AI Foundry","permalink":"/blog/mastra-vs-microsoft-agent-framework"},"nextItem":{"title":"Welcome to my blog!","permalink":"/blog/welcome"}},"content":"In recent years, I\'ve seen two equally damaging extremes in many development teams: **over-engineering** and the **eternal PoC culture**. This post is about why both extremes are bad engineering practices and how to find a reasonable middle ground.\\n\\n\x3c!--truncate--\x3e\\n\\n## What I Call \\"Over-Engineering\\"\\n\\nBy over-engineering, I mean solutions that:\\n\\n* Add **accidental complexity** without providing clear value.\\n* Break basic principles like **KISS** (\\"Keep It Simple, Stupid\\"), **YAGNI** (\\"You Aren\'t Gonna Need It\\"), and **DRY** (\\"Don\'t Repeat Yourself\\").\\n\\nSome typical smells:\\n\\n* Microservices for a product that doesn\'t even have a dedicated PM.\\n* Hexagonal architecture + DDD + CQRS + Event Sourcing\u2026 for an intranet with 50 users.\\n* Internal framework that only the person who created it understands.\\n\\nThe problem isn\'t using advanced patterns; the problem is doing it **without a business case** to support it. Complexity has to be \\"paid for\\" every day: onboarding, debugging, observability, deployments, refactors\u2026\\n\\n> If the cognitive cost of understanding the system is greater than the problem it solves, you\'re probably over-engineering.\\n\\n## What I Call \\"PoC Culture\\" (and Why It\'s Equally Toxic)\\n\\nOn the other extreme is the culture of:\\n\\n> \\"Do a quick PoC, we\'ll put it in production to test it, and we\'ll refactor it later\\".\\n\\nSpoiler: **\\"later\\" never comes**.\\n\\nA PoC (Proof of Concept) is designed to **validate an idea with minimal effort**, not to last for years: it usually doesn\'t have tests, security best practices, or decent observability. Taking that PoC as-is to production is a technical debt factory.\\n\\nAnd here\'s the trap:\\n\\n* The PoC **works**, the business gets used to it.\\n* More things get connected around it.\\n* It becomes \\"scary\\" to touch because \\"it breaks everything\\".\\n* Refactoring becomes increasingly expensive.\\n\\nAs Jason Lengstorf summarized: almost every company has code in production that was born as a PoC and was never rewritten.\\n\\n## Technical Debt: Tool, Not Excuse\\n\\nThis is where the concept of **technical debt** comes in: taking a shortcut now knowing that you\'ll pay an extra maintenance cost in the future.\\n\\nMartin Fowler proposes a very useful quadrant: **prudent vs reckless** and **deliberate vs inadvertent**.\\n\\n* **Deliberate + prudent**:\\n  You know you\'re introducing debt, you accept it consciously, and you have a plan to pay it off. Example: doing something more \\"hardcoded\\" to reach a launch, with a task created to refactor later.\\n\\n* **Deliberate + reckless**:\\n  \\"We don\'t have time for design, we\'ll see\\". No cleanup plan. This is gasoline for future fires.\\n\\n* **Inadvertent + prudent**:\\n  You did the best you knew how, but later you learn a better way. Normal.\\n\\n* **Inadvertent + reckless**:\\n  Sloppy code due to lack of knowledge and no intention to improve.\\n\\nThe moral: **good technical debt exists** (it\'s a strategic investment); the bad kind is what you introduce unknowingly or knowing you won\'t pay it off.\\n\\n## How Over-Engineering and PoC Culture Feed Each Other\\n\\nThe funny (or sad) thing is that these two pathologies **reinforce each other**:\\n\\n1. A team suffers from over-engineering:\\n   * Changing anything in the system is extremely expensive.\\n   * Everything takes weeks.\\n   * The business gets frustrated.\\n\\n2. The business responds with \\"PoC mode\\":\\n   * \\"Do something quick on the side, even if it\'s ugly, but make it work now\\".\\n   * A parallel PoC is born, without engineering discipline.\\n\\n3. That PoC ends up in production.\\n   * Now you have a monster: excessive architecture on one side, experimental spaghetti on the other.\\n\\nAnd around we go again.\\n\\n## Practical Framework for Devs/Architects: Quick PoC or \\"Real\\" Engineering?\\n\\nAs an architect or technical lead, your job isn\'t to apply textbook patterns, but to **make conscious cost/benefit decisions**.\\n\\n### 1. Quick Check to Avoid Over-Engineering\\n\\nBefore adding another layer, another microservice, or a new pattern, ask yourself:\\n\\n1. **What specific problem does this solve today?**\\n   If the answer is \\"in case tomorrow\u2026\\", it sounds like YAGNI.\\n\\n2. **Do I have real signals that the future is coming?**\\n   Metrics, roadmap, customers, not just \\"architectural intuition\\".\\n\\n3. **Can I start with something simpler and extract it later?**\\n   For example:\\n   * Start with a module in a monolith \u2192 extract to microservice when there\'s clear need.\\n   * Start with a single database \u2192 separate later by bounded contexts when it really hurts.\\n\\n4. **Is my team prepared for the complexity I\'m introducing?**\\n   An architecture is only as good as the people who have to maintain it.\\n\\nIf you can\'t justify the complexity in terms of **reduced risk or saved cost**, you\'re probably designing for your ego rather than the product.\\n\\n### 2. Quick Check to Avoid the Eternal PoC\\n\\nWhen someone says \\"it\'s just a test\\", think:\\n\\n1. **Could this code be in production in 6\u201312 months?**\\n   If the honest answer is \\"yes, likely\\", then it\'s not \\"just a PoC\\":\\n   * require minimum quality,\\n   * at least some basic tests,\\n   * decent logging and some observability.\\n\\n2. **What part of the system depends on this?**\\n   * Will it move money?\\n   * Does it affect critical data?\\n   * The main user experience?\\n\\n3. **Is the debt I\'m introducing recorded?**\\n   \\"We\'ll refactor it later\\" doesn\'t cut it:\\n   * write concrete tickets,\\n   * assign priorities,\\n   * comment the context in the code when taking shortcuts.\\n\\n4. **Is there an \\"expiration date\\" for this PoC?**\\n   For example:\\n   > \\"This PoC service will live for a maximum of 3 months. If after 3 months it\'s still providing value, we plan its rewrite/industrialization\\".\\n\\nWithout a timebox, the PoC mutates into legacy system.\\n\\n## Recommended Work Pattern: PoC \u2192 Prototype \u2192 Product\\n\\nA healthy way to work (especially in cloud/SaaS environments) is to think in three levels:\\n\\n1. **PoC**\\n   * Objective: validate an idea (technical or business).\\n   * Minimum criteria:\\n     * It can break; it\'s for controlled environment.\\n     * You document consciously: *\\"not intended for production\\"*.\\n\\n2. **\\"Production-like\\" Prototype**\\n   * Objective: approach what the real version would be.\\n   * Here you already apply:\\n     * architecture that makes sense,\\n     * clear boundaries,\\n     * basic security,\\n     * minimum observability.\\n\\n3. **Stable Product/Service**\\n   * Objective: operate in production for years.\\n   * Requires:\\n     * clear SLOs/SLAs,\\n     * serious pipelines,\\n     * reliability metrics,\\n     * evolution strategy.\\n\\nThe PoC \u2192 product jump **without an intermediate phase** is what so often ends in technical debt nightmare.\\n\\n## What You Can Do as a Dev/Architect (Even If You\'re Not \\"CTO\\")\\n\\nSome very concrete actions you can incorporate into your daily practice:\\n\\n* **Put language to shortcuts**\\n  When someone asks \\"do it quickly\\":\\n  * \\"Okay, but that implies technical debt of type X. We accept it if we then dedicate Y hours to cleaning it up\\".\\n\\n* **Visualize complexity**\\n  * Simple diagrams (C4 level 1\u20132) to show when the architecture is becoming absurd for the product size.\\n\\n* **Measure the pain**\\n  * \\"Every change in this module takes us two weeks and breaks three things\\".\\n  * That opens doors to propose refactors, simplification, or re-architecture.\\n\\n* **Negotiate conditions for a PoC**\\n  * Clear timebox.\\n  * What can be sacrificed (performance, internal cleanliness) and what CANNOT (basic security, privacy, data integrity).\\n\\n## Conclusion: Engineering \u2260 Dogma, It\'s Managing Trade-offs\\n\\nNot every project deserves a textbook architecture, nor is anything acceptable with \\"it\'s just a test\\". Both extremes are, fundamentally, **lack of engineering**:\\n\\n* Over-engineering ignores the real cost of complexity.\\n* Eternal PoC culture ignores the real cost of technical debt.\\n\\nReal software engineering is about this:\\n\\n> **Making explicit decisions about where you accept complexity and where you accept debt, with a plan to manage both over time.**\\n\\nIf you take one thing from this post, let it be this idea:\\n\\n* When you\'re going to design: ask yourself *\\"can I make it simpler without losing the essential?\\"*.\\n* When you\'re going to \\"do something quick\\": ask yourself *\\"am I willing to pay the price of leaving it like this?\\"*.\\n\\nYou won\'t find the balance in any book: you\'ll build it yourself, project by project, decision by decision.\\n\\n---\\n\\n## References\\n\\n* [KISS vs. DRY vs. YAGNI: Understanding Key Software Development Principles](https://rrmartins.medium.com/kiss-vs-dry-vs-yagni-understanding-key-software-development-principles-e307b7419636)\\n* [Technical Debt Quadrant - Martin Fowler](https://martinfowler.com/bliki/TechnicalDebtQuadrant.html)\\n* [When Proof of Concepts Become Production Code](https://blog.scaledcode.com/blog/poc-to-production/)\\n* [YAGNI - Martin Fowler](https://martinfowler.com/bliki/Yagni.html)"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","source":"@site/blog/2025-11-15-welcome.md","title":"Welcome to my blog!","description":"Hello and welcome to my personal blog! \ud83d\udc4b","date":"2025-11-15T00:00:00.000Z","tags":[{"inline":false,"label":"Personal","permalink":"/blog/tags/personal","description":"Personal posts"}],"readingTime":1.07,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"welcome","title":"Welcome to my blog!","authors":["valdepeace"],"tags":["personal"]},"unlisted":false,"prevItem":{"title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","permalink":"/blog/over-engineering-vs-poc"}},"content":"Hello and welcome to my personal blog! \ud83d\udc4b\\n\\nThis is the first post of many to come. Here I\'ll share my experiences, learnings, and reflections about technology, software development, and everything I\'m passionate about.\\n\\n\x3c!--truncate--\x3e\\n\\n## What will you find here?\\n\\nIn this space I\'ll publish content about:\\n\\n- **\ud83d\udcbb Web Development:** Tutorials, tips, and best practices\\n- **\ud83d\ude80 Modern Technologies:** React, TypeScript, Node.js, and more\\n- **\ud83d\udcda Learnings:** Experiences and lessons learned\\n- **\ud83d\udd27 Tools:** Reviews and guides for useful tools\\n- **\ud83d\udca1 Ideas:** Reflections about the tech industry\\n\\n## My vision\\n\\nI firmly believe in sharing knowledge. The developer community has been incredibly generous with me, and this is my way of giving back a little of what I\'ve received.\\n\\nDon\'t expect perfect posts, but honest, practical, and useful content based on real experiences.\\n\\n## What\'s coming?\\n\\nIn the upcoming posts I\'ll talk about:\\n\\n- How I set up this site with Docusaurus\\n- Best practices in React and TypeScript\\n- Tools I use daily\\n- Projects I\'m working on\\n\\n## Stay connected\\n\\nIf you\'re interested in the content, you can:\\n\\n- Subscribe to the [RSS feed](/blog/rss.xml)\\n- Follow me on [Twitter](https://twitter.com/valdepeace)\\n- Connect on [LinkedIn](https://www.linkedin.com/in/valdepeace)\\n- See my work on [GitHub](https://github.com/valdepeace)\\n\\nThanks for being here! \ud83d\ude80\\n\\n---\\n\\n*Do you have any topic you\'d like me to cover? Leave me a comment or contact me!*"}]}}')}}]);