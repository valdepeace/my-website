"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"mastra-vs-microsoft-agent-framework","metadata":{"permalink":"/blog/mastra-vs-microsoft-agent-framework","source":"@site/blog/2025-11-29-mastra-vs-microsoft-agent-framework.md","title":"Mastra vs Microsoft Agent Framework + Azure AI Foundry \u2014 A Practical Comparison","description":"Summary: A concise comparison between Mastra (TypeScript-first agent framework) and Microsoft\'s Agent Framework + Azure AI Foundry (Microsoft\'s managed agent platform).","date":"2025-11-29T00:00:00.000Z","tags":[{"inline":false,"label":"Mastra","permalink":"/blog/tags/mastra","description":"Mastra TypeScript agent framework"},{"inline":false,"label":"Microsoft Agent Framework","permalink":"/blog/tags/microsoft-agent-framework","description":"Microsoft Agent Framework and Azure AI Foundry"},{"inline":false,"label":"Comparison","permalink":"/blog/tags/comparison","description":"Comparative articles"},{"inline":false,"label":"AI Agents","permalink":"/blog/tags/ai-agents","description":"Agent frameworks and AI agents"}],"readingTime":1.81,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"mastra-vs-microsoft-agent-framework","title":"Mastra vs Microsoft Agent Framework + Azure AI Foundry \u2014 A Practical Comparison","authors":["valdepeace"],"tags":["mastra","microsoft-agent-framework","comparison","ai-agents"]},"unlisted":false,"nextItem":{"title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","permalink":"/blog/over-engineering-vs-poc"}},"content":"Summary: A concise comparison between Mastra (TypeScript-first agent framework) and Microsoft\'s Agent Framework + Azure AI Foundry (Microsoft\'s managed agent platform).\\r\\n\\r\\n## 1. One-line summary\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n---\\r\\n\\r\\n## 2. Quick comparison\\r\\n\\r\\n| Aspect | Mastra | Microsoft Agent Framework + Azure AI Foundry |\\r\\n|---|---|---|\\r\\n| Language / runtime | TypeScript / Node \u2014 ideal if your stack is JS | .NET and Python \u2014 first-class in Azure environments |\\r\\n| Mental model | TypeScript-first framework for agents, pipelines, RAG, tracing, MCP | SDK + runtime for multi-agent graphs, successor of Semantic Kernel / AutoGen |\\r\\n| Deployment | Self-host anywhere; Mastra Cloud for traces/evals | Standalone or connected to managed Foundry Agent Service in Azure |\\r\\n| Model vendors | Multi-provider (OpenAI, Azure OpenAI, Claude, Gemini, Llama...) | Multi-provider with first-class Azure model integrations |\\r\\n| Workflows & orchestration | Pipeline / graph style in TS, suspend/resume, streaming | Graph-based orchestration, conditional routing, long-running, HITL |\\r\\n| RAG / Connectors | Vector stores (Postgres, Pinecone), RAG templates | Native integration with Azure AI Search, Fabric, OneLake, SharePoint |\\r\\n| MCP & tools | Strong MCP support, agent networks and tools | MCP as a tool type; Foundry provides catalog of managed resources |\\r\\n| Observability | Mastra Cloud: traces, evals, scoring, UI | OpenTelemetry + Azure Monitor; platform dashboards & governance |\\r\\n| Azure integration | Can run in Azure but agnostic by design | Deep, official Azure integration (Foundry, Fabric, Entra, Defender) |\\r\\n| License / community | Open source (Apache 2.0); JS-focused community | Open source (MIT) + Microsoft ecosystem & docs |\\r\\n\\r\\n---\\r\\n\\r\\n## 3. Which to choose depending on context\\r\\n\\r\\n- If your stack is Node/TypeScript and you want fast iteration, Mastra is the natural fit: same language, quick developer velocity, good for MCP and scrapers.\\r\\n- If you need full enterprise Azure governance (Foundry, Fabric, Defender, Entra), or your customer requires a managed Azure solution, Microsoft Agent Framework + Foundry is appropriate.\\r\\n\\r\\n**Hybrid approach (recommended for mixed environments):**\\r\\n\\r\\n1. Keep an agent core in JS (Mastra) for rapid iteration and product features.\\r\\n2. For enterprise-grade RAG or Azure-centred customers, deploy Agent Framework / Foundry agents as managed services and expose them as APIs.\\r\\n3. Use your Node/Mastra code to orchestrate and call those managed agents where strict governance is required.\\r\\n\\r\\n---\\r\\n\\r\\n## 4. TL;DR / Practical suggestion\\r\\n\\r\\n- For quick PoCs, internal automations, scrapers and MCP-first flows: **Mastra**.\\r\\n- For regulated corporate projects inside Azure, where governance and integrations matter: **MAF + Foundry**."},{"id":"over-engineering-vs-poc","metadata":{"permalink":"/blog/over-engineering-vs-poc","source":"@site/blog/2025-11-16-over-engineering-vs-poc.md","title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","description":"In recent years, I\'ve seen two equally damaging extremes in many development teams: over-engineering and the eternal PoC culture. This post is about why both extremes are bad engineering practices and how to find a reasonable middle ground.","date":"2025-11-16T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture","description":"Software architecture"},{"inline":false,"label":"Best Practices","permalink":"/blog/tags/best-practices","description":"Software development best practices"},{"inline":false,"label":"Software Engineering","permalink":"/blog/tags/software-engineering","description":"Software engineering principles and practices"},{"inline":false,"label":"Technical Debt","permalink":"/blog/tags/technical-debt","description":"Technical debt management"}],"readingTime":6.54,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"over-engineering-vs-poc","title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","authors":["valdepeace"],"tags":["architecture","best-practices","software-engineering","technical-debt"]},"unlisted":false,"prevItem":{"title":"Mastra vs Microsoft Agent Framework + Azure AI Foundry \u2014 A Practical Comparison","permalink":"/blog/mastra-vs-microsoft-agent-framework"},"nextItem":{"title":"Welcome to my blog!","permalink":"/blog/welcome"}},"content":"In recent years, I\'ve seen two equally damaging extremes in many development teams: **over-engineering** and the **eternal PoC culture**. This post is about why both extremes are bad engineering practices and how to find a reasonable middle ground.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## What I Call \\"Over-Engineering\\"\\r\\n\\r\\nBy over-engineering, I mean solutions that:\\r\\n\\r\\n* Add **accidental complexity** without providing clear value.\\r\\n* Break basic principles like **KISS** (\\"Keep It Simple, Stupid\\"), **YAGNI** (\\"You Aren\'t Gonna Need It\\"), and **DRY** (\\"Don\'t Repeat Yourself\\").\\r\\n\\r\\nSome typical smells:\\r\\n\\r\\n* Microservices for a product that doesn\'t even have a dedicated PM.\\r\\n* Hexagonal architecture + DDD + CQRS + Event Sourcing\u2026 for an intranet with 50 users.\\r\\n* Internal framework that only the person who created it understands.\\r\\n\\r\\nThe problem isn\'t using advanced patterns; the problem is doing it **without a business case** to support it. Complexity has to be \\"paid for\\" every day: onboarding, debugging, observability, deployments, refactors\u2026\\r\\n\\r\\n> If the cognitive cost of understanding the system is greater than the problem it solves, you\'re probably over-engineering.\\r\\n\\r\\n## What I Call \\"PoC Culture\\" (and Why It\'s Equally Toxic)\\r\\n\\r\\nOn the other extreme is the culture of:\\r\\n\\r\\n> \\"Do a quick PoC, we\'ll put it in production to test it, and we\'ll refactor it later\\".\\r\\n\\r\\nSpoiler: **\\"later\\" never comes**.\\r\\n\\r\\nA PoC (Proof of Concept) is designed to **validate an idea with minimal effort**, not to last for years: it usually doesn\'t have tests, security best practices, or decent observability. Taking that PoC as-is to production is a technical debt factory.\\r\\n\\r\\nAnd here\'s the trap:\\r\\n\\r\\n* The PoC **works**, the business gets used to it.\\r\\n* More things get connected around it.\\r\\n* It becomes \\"scary\\" to touch because \\"it breaks everything\\".\\r\\n* Refactoring becomes increasingly expensive.\\r\\n\\r\\nAs Jason Lengstorf summarized: almost every company has code in production that was born as a PoC and was never rewritten.\\r\\n\\r\\n## Technical Debt: Tool, Not Excuse\\r\\n\\r\\nThis is where the concept of **technical debt** comes in: taking a shortcut now knowing that you\'ll pay an extra maintenance cost in the future.\\r\\n\\r\\nMartin Fowler proposes a very useful quadrant: **prudent vs reckless** and **deliberate vs inadvertent**.\\r\\n\\r\\n* **Deliberate + prudent**:\\r\\n  You know you\'re introducing debt, you accept it consciously, and you have a plan to pay it off. Example: doing something more \\"hardcoded\\" to reach a launch, with a task created to refactor later.\\r\\n\\r\\n* **Deliberate + reckless**:\\r\\n  \\"We don\'t have time for design, we\'ll see\\". No cleanup plan. This is gasoline for future fires.\\r\\n\\r\\n* **Inadvertent + prudent**:\\r\\n  You did the best you knew how, but later you learn a better way. Normal.\\r\\n\\r\\n* **Inadvertent + reckless**:\\r\\n  Sloppy code due to lack of knowledge and no intention to improve.\\r\\n\\r\\nThe moral: **good technical debt exists** (it\'s a strategic investment); the bad kind is what you introduce unknowingly or knowing you won\'t pay it off.\\r\\n\\r\\n## How Over-Engineering and PoC Culture Feed Each Other\\r\\n\\r\\nThe funny (or sad) thing is that these two pathologies **reinforce each other**:\\r\\n\\r\\n1. A team suffers from over-engineering:\\r\\n   * Changing anything in the system is extremely expensive.\\r\\n   * Everything takes weeks.\\r\\n   * The business gets frustrated.\\r\\n\\r\\n2. The business responds with \\"PoC mode\\":\\r\\n   * \\"Do something quick on the side, even if it\'s ugly, but make it work now\\".\\r\\n   * A parallel PoC is born, without engineering discipline.\\r\\n\\r\\n3. That PoC ends up in production.\\r\\n   * Now you have a monster: excessive architecture on one side, experimental spaghetti on the other.\\r\\n\\r\\nAnd around we go again.\\r\\n\\r\\n## Practical Framework for Devs/Architects: Quick PoC or \\"Real\\" Engineering?\\r\\n\\r\\nAs an architect or technical lead, your job isn\'t to apply textbook patterns, but to **make conscious cost/benefit decisions**.\\r\\n\\r\\n### 1. Quick Check to Avoid Over-Engineering\\r\\n\\r\\nBefore adding another layer, another microservice, or a new pattern, ask yourself:\\r\\n\\r\\n1. **What specific problem does this solve today?**\\r\\n   If the answer is \\"in case tomorrow\u2026\\", it sounds like YAGNI.\\r\\n\\r\\n2. **Do I have real signals that the future is coming?**\\r\\n   Metrics, roadmap, customers, not just \\"architectural intuition\\".\\r\\n\\r\\n3. **Can I start with something simpler and extract it later?**\\r\\n   For example:\\r\\n   * Start with a module in a monolith \u2192 extract to microservice when there\'s clear need.\\r\\n   * Start with a single database \u2192 separate later by bounded contexts when it really hurts.\\r\\n\\r\\n4. **Is my team prepared for the complexity I\'m introducing?**\\r\\n   An architecture is only as good as the people who have to maintain it.\\r\\n\\r\\nIf you can\'t justify the complexity in terms of **reduced risk or saved cost**, you\'re probably designing for your ego rather than the product.\\r\\n\\r\\n### 2. Quick Check to Avoid the Eternal PoC\\r\\n\\r\\nWhen someone says \\"it\'s just a test\\", think:\\r\\n\\r\\n1. **Could this code be in production in 6\u201312 months?**\\r\\n   If the honest answer is \\"yes, likely\\", then it\'s not \\"just a PoC\\":\\r\\n   * require minimum quality,\\r\\n   * at least some basic tests,\\r\\n   * decent logging and some observability.\\r\\n\\r\\n2. **What part of the system depends on this?**\\r\\n   * Will it move money?\\r\\n   * Does it affect critical data?\\r\\n   * The main user experience?\\r\\n\\r\\n3. **Is the debt I\'m introducing recorded?**\\r\\n   \\"We\'ll refactor it later\\" doesn\'t cut it:\\r\\n   * write concrete tickets,\\r\\n   * assign priorities,\\r\\n   * comment the context in the code when taking shortcuts.\\r\\n\\r\\n4. **Is there an \\"expiration date\\" for this PoC?**\\r\\n   For example:\\r\\n   > \\"This PoC service will live for a maximum of 3 months. If after 3 months it\'s still providing value, we plan its rewrite/industrialization\\".\\r\\n\\r\\nWithout a timebox, the PoC mutates into legacy system.\\r\\n\\r\\n## Recommended Work Pattern: PoC \u2192 Prototype \u2192 Product\\r\\n\\r\\nA healthy way to work (especially in cloud/SaaS environments) is to think in three levels:\\r\\n\\r\\n1. **PoC**\\r\\n   * Objective: validate an idea (technical or business).\\r\\n   * Minimum criteria:\\r\\n     * It can break; it\'s for controlled environment.\\r\\n     * You document consciously: *\\"not intended for production\\"*.\\r\\n\\r\\n2. **\\"Production-like\\" Prototype**\\r\\n   * Objective: approach what the real version would be.\\r\\n   * Here you already apply:\\r\\n     * architecture that makes sense,\\r\\n     * clear boundaries,\\r\\n     * basic security,\\r\\n     * minimum observability.\\r\\n\\r\\n3. **Stable Product/Service**\\r\\n   * Objective: operate in production for years.\\r\\n   * Requires:\\r\\n     * clear SLOs/SLAs,\\r\\n     * serious pipelines,\\r\\n     * reliability metrics,\\r\\n     * evolution strategy.\\r\\n\\r\\nThe PoC \u2192 product jump **without an intermediate phase** is what so often ends in technical debt nightmare.\\r\\n\\r\\n## What You Can Do as a Dev/Architect (Even If You\'re Not \\"CTO\\")\\r\\n\\r\\nSome very concrete actions you can incorporate into your daily practice:\\r\\n\\r\\n* **Put language to shortcuts**\\r\\n  When someone asks \\"do it quickly\\":\\r\\n  * \\"Okay, but that implies technical debt of type X. We accept it if we then dedicate Y hours to cleaning it up\\".\\r\\n\\r\\n* **Visualize complexity**\\r\\n  * Simple diagrams (C4 level 1\u20132) to show when the architecture is becoming absurd for the product size.\\r\\n\\r\\n* **Measure the pain**\\r\\n  * \\"Every change in this module takes us two weeks and breaks three things\\".\\r\\n  * That opens doors to propose refactors, simplification, or re-architecture.\\r\\n\\r\\n* **Negotiate conditions for a PoC**\\r\\n  * Clear timebox.\\r\\n  * What can be sacrificed (performance, internal cleanliness) and what CANNOT (basic security, privacy, data integrity).\\r\\n\\r\\n## Conclusion: Engineering \u2260 Dogma, It\'s Managing Trade-offs\\r\\n\\r\\nNot every project deserves a textbook architecture, nor is anything acceptable with \\"it\'s just a test\\". Both extremes are, fundamentally, **lack of engineering**:\\r\\n\\r\\n* Over-engineering ignores the real cost of complexity.\\r\\n* Eternal PoC culture ignores the real cost of technical debt.\\r\\n\\r\\nReal software engineering is about this:\\r\\n\\r\\n> **Making explicit decisions about where you accept complexity and where you accept debt, with a plan to manage both over time.**\\r\\n\\r\\nIf you take one thing from this post, let it be this idea:\\r\\n\\r\\n* When you\'re going to design: ask yourself *\\"can I make it simpler without losing the essential?\\"*.\\r\\n* When you\'re going to \\"do something quick\\": ask yourself *\\"am I willing to pay the price of leaving it like this?\\"*.\\r\\n\\r\\nYou won\'t find the balance in any book: you\'ll build it yourself, project by project, decision by decision.\\r\\n\\r\\n---\\r\\n\\r\\n## References\\r\\n\\r\\n* [KISS vs. DRY vs. YAGNI: Understanding Key Software Development Principles](https://rrmartins.medium.com/kiss-vs-dry-vs-yagni-understanding-key-software-development-principles-e307b7419636)\\r\\n* [Technical Debt Quadrant - Martin Fowler](https://martinfowler.com/bliki/TechnicalDebtQuadrant.html)\\r\\n* [When Proof of Concepts Become Production Code](https://blog.scaledcode.com/blog/poc-to-production/)\\r\\n* [YAGNI - Martin Fowler](https://martinfowler.com/bliki/Yagni.html)"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","source":"@site/blog/2025-11-15-welcome.md","title":"Welcome to my blog!","description":"Hello and welcome to my personal blog! \ud83d\udc4b","date":"2025-11-15T00:00:00.000Z","tags":[{"inline":false,"label":"Personal","permalink":"/blog/tags/personal","description":"Personal posts"}],"readingTime":1.07,"hasTruncateMarker":true,"authors":[{"name":"Andr\xe9s Carmona Gil","title":"Desarrollador & Creador de Contenido","url":"https://github.com/valdepeace","page":{"permalink":"/blog/authors/valdepeace"},"socials":{"x":"https://x.com/valdepeace","linkedin":"https://www.linkedin.com/in/valdepeace/","github":"https://github.com/valdepeace"},"imageURL":"https://github.com/valdepeace.png","key":"valdepeace"}],"frontMatter":{"slug":"welcome","title":"Welcome to my blog!","authors":["valdepeace"],"tags":["personal"]},"unlisted":false,"prevItem":{"title":"Not Everything is a PoC, and You Don\'t Need Netflix for a CRUD","permalink":"/blog/over-engineering-vs-poc"}},"content":"Hello and welcome to my personal blog! \ud83d\udc4b\\r\\n\\r\\nThis is the first post of many to come. Here I\'ll share my experiences, learnings, and reflections about technology, software development, and everything I\'m passionate about.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## What will you find here?\\r\\n\\r\\nIn this space I\'ll publish content about:\\r\\n\\r\\n- **\ud83d\udcbb Web Development:** Tutorials, tips, and best practices\\r\\n- **\ud83d\ude80 Modern Technologies:** React, TypeScript, Node.js, and more\\r\\n- **\ud83d\udcda Learnings:** Experiences and lessons learned\\r\\n- **\ud83d\udd27 Tools:** Reviews and guides for useful tools\\r\\n- **\ud83d\udca1 Ideas:** Reflections about the tech industry\\r\\n\\r\\n## My vision\\r\\n\\r\\nI firmly believe in sharing knowledge. The developer community has been incredibly generous with me, and this is my way of giving back a little of what I\'ve received.\\r\\n\\r\\nDon\'t expect perfect posts, but honest, practical, and useful content based on real experiences.\\r\\n\\r\\n## What\'s coming?\\r\\n\\r\\nIn the upcoming posts I\'ll talk about:\\r\\n\\r\\n- How I set up this site with Docusaurus\\r\\n- Best practices in React and TypeScript\\r\\n- Tools I use daily\\r\\n- Projects I\'m working on\\r\\n\\r\\n## Stay connected\\r\\n\\r\\nIf you\'re interested in the content, you can:\\r\\n\\r\\n- Subscribe to the [RSS feed](/blog/rss.xml)\\r\\n- Follow me on [Twitter](https://twitter.com/valdepeace)\\r\\n- Connect on [LinkedIn](https://www.linkedin.com/in/valdepeace)\\r\\n- See my work on [GitHub](https://github.com/valdepeace)\\r\\n\\r\\nThanks for being here! \ud83d\ude80\\r\\n\\r\\n---\\r\\n\\r\\n*Do you have any topic you\'d like me to cover? Leave me a comment or contact me!*"}]}}')}}]);